<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>ãƒã‚±ã‚¹ãƒªé£Ÿæè¨ˆç®—ãƒ„ãƒ¼ãƒ«ï¼ˆOCRçµ±åˆãƒ»ä¸Šæ›¸ãåæ˜ ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ï¼ˆãƒ¢ãƒã‚¤ãƒ«â†’ç¸¦ã€lgä»¥ä¸Šâ†’å·¦å³ï¼‰ */
    .sticky-col { position: sticky; top: 1rem; }
    .qty-input { text-align: center; }
    .w-9ch { width: 9ch; }
    .w-6ch { width: 6ch; } /* G3 æ‰€æŒå…¥åŠ›ã‚’ç‹­ã */
    .table-sm td, .table-sm th { vertical-align: middle; }
    #totalTable th { white-space: nowrap; } /* ãƒ˜ãƒƒãƒ€ãƒ¼æŠ˜è¿”ã—é˜²æ­¢ */
    .empty-hint { color: #6c757d; }

    /* æ•°å€¤å…¥åŠ›ã®ã‚¹ãƒ”ãƒ³ãƒˆã‚°ãƒ«éè¡¨ç¤ºï¼ˆå…¨ä½“ï¼‰ */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }

    /* ã‚¹ãƒ†ãƒƒãƒ‘ãƒ¼å¹…ï¼šçµ±ä¸€ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—1/2å…±é€šï¼‰ */
    .stepper-compact { width: 130px; max-width: 130px; }

    /* ã‚¹ãƒ†ãƒƒãƒ‘ãƒ¼ãƒœã‚¿ãƒ³å¹…å›ºå®šï¼ˆç«¯æœ«å·®ã‚’å¸åï¼‰ */
    .btn-step { width: 36px; padding-left: 0; padding-right: 0; display: inline-flex; justify-content: center; align-items: center; }

    /* --- é£Ÿæç”»åƒUI --- */
    .ing-img { display: inline-block; object-fit: contain; border-radius: .35rem; background-color: #f8f9fa; }
    .ing-32 { width: 32px; height: 32px; }
    .ing-28 { width: 28px; height: 28px; }

    .ing-chip { display: inline-flex; align-items: center; gap: .35rem; padding: .15rem .2rem; flex: 0 0 auto; }
    .ing-count { font-variant-numeric: tabular-nums; }

    .ing-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: .35rem .75rem; }
    .ing-grid-item { display: inline-flex; align-items: center; gap: .35rem; min-width: 0; }

    .ing-label-minitext { font-size: 10px; color: #6c757d; white-space: nowrap; }

    /* G3ï¼š2ã€œ4åˆ—ï¼ˆå¿…è¦ãƒ»æ‰€æŒãƒ»ä¸è¶³ï¼‰ä¸­å¤®å¯„ã› */
    #totalTable th:nth-child(2),
    #totalTable th:nth-child(3),
    #totalTable th:nth-child(4),
    #totalTable td:nth-child(2),
    #totalTable td:nth-child(3),
    #totalTable td:nth-child(4) { text-align: center; }
    #totalTable td:nth-child(3) .form-control { margin-left: auto; margin-right: auto; text-align: center; }

    /* ã‚«ãƒ¡ãƒ©UI */
    .camera-stack { display: grid; gap: .5rem; }

    /* G1ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼šå¸¸ã«æ¨ªä¸€è¡Œï¼ˆæ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰ */
    #g1Preview { display: flex; gap: .5rem; flex-wrap: nowrap; overflow-x: auto; -webkit-overflow-scrolling: touch; white-space: nowrap; }

    /* OCRãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é ˜åŸŸï¼ˆåˆæœŸã¯éè¡¨ç¤ºï¼‰ */
    #gridPreview { display: flex; flex-direction: column; gap: .5rem; border: 1px dashed #dee2e6; border-radius: .5rem; background: #f8f9fa; padding: .5rem; }
    #tileThumbs { display: flex; gap: 6px; overflow-x: auto; white-space: nowrap; min-height: 64px; }
    #gridPreview, #gridPreview * { cursor: default; }

    /* ãƒãƒƒã‚¸ï¼ˆã‚„ã‚ã‚‰ã‹è‰²ï¼‰ */
    .badge-soft { color: #0c5460; background: #e2f3f5; border: 1px solid #bde1e6; }

    /* ç¢ºèªãƒ‘ãƒãƒ« */
    #confirmPanel .card-title small { color: #6c757d; }
    .tile-thumb { width: 40px; height: auto; border: 1px solid #eee; border-radius: 4px; }

    /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ */
    .toast-container { position: fixed; inset: auto 1rem 1rem auto; z-index: 1080; }

    /* ãƒ‡ãƒãƒƒã‚°é ˜åŸŸï¼ˆæ—¢å®šOFFï¼‰ */
    #ocrDebug { display: none; }

/* --- Preview in-card behavior --- */
#gridPreview {
  max-width: 100%;
  overflow: hidden;          /* ã‚«ãƒ¼ãƒ‰å¤–ã«ã¯ã¿å‡ºã•ãªã„ */
  padding: .5rem;
}
#tileThumbs {
  display: flex;
  gap: 6px;
  flex-wrap: nowrap;         /* æ¨ªä¸€åˆ—å›ºå®š */
  overflow-x: auto;          /* æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
  overflow-y: hidden;        /* ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ç¦æ­¢ */
  -webkit-overflow-scrolling: touch;
  max-width: 100%;
}
.tile-thumb {
  flex: 0 0 auto;            /* å›ºå®šå¹…ã§ä¸¦ã¹ã‚‹ */
  width: 40px;
  height: auto;
}

/* æœ€æœ‰åŠ›ãƒ©ã‚¤ãƒ³ã¯éè¡¨ç¤ºï¼ˆè¦æœ›ã«ã‚ˆã‚Šï¼‰ */
#bestLine { display: none !important; }

  </style>
  <link rel="icon" href="data:,">
</head>
<body>
  <header class="container py-3">
    <h1 class="h4 m-0">ãƒã‚±ã‚¹ãƒªé£Ÿæè¨ˆç®—ãƒ„ãƒ¼ãƒ«</h1>
    <p class="text-muted small mb-0">dataset.json èª­ã¿è¾¼ã¿ï¼A/B/Cã‚°ãƒ«ãƒ¼ãƒ—ãƒ»slugé †å¯¾å¿œï¼é£Ÿæç”»åƒUIï¼OCRã§æ‰€æŒä¸Šæ›¸ã</p>
  </header>

  <main class="container">
    <div class="row g-3">
      <!-- å·¦ã‚«ãƒ©ãƒ ï¼šã‚°ãƒ«ãƒ¼ãƒ—1ï¼†2 -->
      <div class="col-12 col-lg-6">
        <div class="sticky-col">
          <!-- ANCHOR:G1 -->
          <div class="card mb-3">
            <div class="card-body">
              <div class="mb-2">
                <div class="btn-group" role="group" aria-label="weekly group">
                  <input type="radio" class="btn-check" name="weeklyGroup" id="wgA" autocomplete="off" value="A" checked>
                  <label class="btn btn-outline-primary" for="wgA" id="wgLabelA">ã‚«ãƒ¬ãƒ¼</label>
                  <input type="radio" class="btn-check" name="weeklyGroup" id="wgB" autocomplete="off" value="B">
                  <label class="btn btn-outline-primary" for="wgB" id="wgLabelB">ã‚µãƒ©ãƒ€</label>
                  <input type="radio" class="btn-check" name="weeklyGroup" id="wgC" autocomplete="off" value="C">
                  <label class="btn btn-outline-primary" for="wgC" id="wgLabelC">ãƒ‡ã‚¶ãƒ¼ãƒˆ</label>
                </div>
              </div>

              <div class="mb-2">
                <select id="recipeSelect" class="form-select" aria-label="æ–™ç†ã‚’é¸æŠ"></select>
              </div>

              <!-- G1ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæ¨ªä¸€è¡Œå›ºå®šã€æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰ -->
              <div id="g1Preview" class="g1-preview small mb-2" aria-live="polite" aria-atomic="true"></div>

              <div class="input-group input-group-sm stepper-compact">
                <button id="qtyMinus" class="btn btn-outline-secondary btn-step" type="button">ï¼</button>
                <input id="qtyInput" class="form-control qty-input" type="number" inputmode="numeric" pattern="[0-9]*" value="1" min="1" step="1">
                <button id="qtyPlus" class="btn btn-outline-secondary btn-step" type="button">ï¼‹</button>
              </div>

              <div class="mt-2">
                <button id="addBtn" class="btn btn-primary btn-sm" type="button">è¿½åŠ </button>
              </div>
            </div>
          </div>

          <!-- ANCHOR:G2 -->
          <div id="group2Card" class="card d-none">
            <div class="card-header d-flex align-items-center justify-content-between">
              <span class="fw-semibold">è¿½åŠ æ¸ˆã¿ãƒ¬ã‚·ãƒ”</span>
              <button id="clearAllBtn" class="btn btn-sm btn-outline-danger" type="button" aria-label="è¿½åŠ æ¸ˆã¿ãƒ¬ã‚·ãƒ”ã‚’å…¨å‰Šé™¤">å…¨å‰Šé™¤</button>
            </div>
            <div class="card-body" id="group2Body">
              <p class="empty-hint m-0">ã¾ã æ–™ç†ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€Œè¿½åŠ ã€ã§æŠ•å…¥ã—ã¦ãã ã•ã„ã€‚</p>
            </div>
          </div>
        </div>
      </div>

      <!-- å³ã‚«ãƒ©ãƒ ï¼šã‚°ãƒ«ãƒ¼ãƒ—3ï¼ˆå¸¸æ™‚è¡¨ç¤ºï¼‰ -->
      <div class="col-12 col-lg-6">
        <!-- ANCHOR:G3 -->
        <div id="group3Card" class="card">
          <div class="card-header d-flex align-items-center justify-content-between">
            <span class="fw-semibold">é£Ÿæåˆè¨ˆ</span>
            <button id="resetStockBtn" class="btn btn-sm btn-outline-secondary" type="button" aria-label="åœ¨åº«ã‚’ã‚¯ãƒªã‚¢">åœ¨åº«ã‚¯ãƒªã‚¢</button>
          </div>
          <div class="card-body">
            <!-- â–¼ ã‚«ãƒ¡ãƒ©UI -->
            <div id="cameraPanel" class="mb-3">
              <div class="d-flex align-items-center camera-row gap-2 mb-2">
                <button id="cameraToggle" class="btn btn-outline-secondary btn-sm" type="button"
                        aria-pressed="false" aria-expanded="false" aria-controls="cameraArea" aria-label="ã‚«ãƒ¡ãƒ©ã‚’é–‹é–‰">ğŸ“·</button>
                <button id="cameraRefresh" class="btn btn-outline-secondary btn-sm ms-2 d-none" type="button" aria-label="ãƒªã‚»ãƒƒãƒˆ">â†»</button>
                <div class="form-check form-switch ms-auto">
                  <input class="form-check-input" type="checkbox" id="debugToggle">
                  <label class="form-check-label small" for="debugToggle">ãƒ‡ãƒãƒƒã‚°</label>
                </div>
              </div>
              <div id="cameraArea" class="camera-stack d-none" aria-hidden="true">
                <div>
                  <input id="cameraFile" type="file" accept="image/*" class="d-none" />
                  <button id="fileSelectBtn" class="btn btn-outline-primary btn-sm" type="button" aria-label="ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
                  <span id="fileName" class="ms-2 text-muted small">æœªé¸æŠ</span>
                </div>
                <!-- è¡Œæ•°é¸æŠï¼ˆ1|2|3|4ï¼‰ -->
                <div>
                  <div id="rowCount" class="btn-group" role="group" aria-label="è¡Œæ•°é¸æŠ">
                    <button type="button" class="btn btn-outline-secondary btn-sm" data-rows="1" aria-pressed="false" title="ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°ã‚’1ã«è¨­å®š">1</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" data-rows="2" aria-pressed="false" title="ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°ã‚’2ã«è¨­å®š">2</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" data-rows="3" aria-pressed="false" title="ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°ã‚’3ã«è¨­å®š">3</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm active" data-rows="4" aria-pressed="true" title="ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°ã‚’4ã«è¨­å®š">4</button>
                  </div>
                </div>
                <!-- gapX, yOffset ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆå°†æ¥çš„ã« tileH ã‚‚è¿½åŠ ä½™åœ°ï¼‰ -->
<!-- gapX â†’ yOffset ã®é †ã«ç¸¦é…ç½® -->
<div class="mb-2">
  <label for="cameraSlider1" class="form-label mb-1 small">åˆ—é–“éš” gapX</label>
  <input id="cameraSlider1" type="range" min="0" max="100" value="50" class="form-range" aria-label="gapX">
</div>
<div class="mb-2">
  <label for="cameraSlider2" class="form-label mb-1 small">ä¸‹ç«¯åŸºæº– yOffset</label>
  <input id="cameraSlider2" type="range" min="0" max="100" value="50" class="form-range" aria-label="yOffset">
</div>

                <div class="d-flex gap-2">
                  <button id="cameraReadBtn" class="btn btn-primary btn-sm" type="button">èª­å–</button>
                  <div id="ocrStatus" class="small text-muted align-self-center"></div>
                </div>
                <!-- ã‚µãƒ ãƒã‚¤ãƒ«ï¼çµæœã®æœ€æœ‰åŠ›å€™è£œãƒ©ã‚¤ãƒ³ï¼ˆç”Ÿæ–‡å­—åˆ—ï¼‰ -->
                <div id="gridPreview" class="mb-2 d-none" aria-label="ã‚°ãƒªãƒƒãƒ‰OCRãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼">
                  <div id="tileThumbs"></div>
                  <div id="bestLine" class="small text-muted"></div>
                </div>
                <!-- ç¢ºèªãƒ‘ãƒãƒ«ï¼ˆã‚ã„ã¾ã„ï¼é‡è¤‡æ™‚ã®ã¿è¡¨ç¤ºï¼‰ -->
                <div id="confirmPanel" class="d-none"></div>
                <!-- æ®‹ã‚¿ã‚¤ãƒ«ã®å‡¦ç†ï¼ˆç ´æ£„/æ‰‹å‹•å‰²å½“ï¼‰ -->
                <div id="leftoverPanel" class="d-none"></div>
                <!-- ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ï¼ˆãƒˆã‚°ãƒ«ONæ™‚ã®ã¿ï¼‰ -->
                <div id="ocrDebug" class="mt-2">
                  <div class="small" style="color:#666">ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ï¼ˆå€ç‡ãƒ»ç”Ÿæ–‡å­—åˆ—ãƒ»å€™è£œãªã©ï¼‰</div>
                  <pre id="debugPre" class="p-2 border bg-light" style="max-height:260px; overflow:auto; font-size:12px;"></pre>
                </div>
              </div>
            </div>
            <!-- â–² ã‚«ãƒ¡ãƒ©UI -->

            <!-- åˆè¨ˆãƒ†ãƒ¼ãƒ–ãƒ« -->
            <div class="table-responsive">
              <table id="totalTable" class="table table-sm align-middle">
                <thead>
                  <tr>
                    <th scope="col">é£Ÿæ</th>
                    <th scope="col">å¿…è¦</th>
                    <th scope="col">æ‰€æŒ</th>
                    <th scope="col">ä¸è¶³</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
              <p id="totalEmpty" class="empty-hint">ã¾ã ãƒ¬ã‚·ãƒ”ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- ãƒˆãƒ¼ã‚¹ãƒˆï¼ˆä¸‹å³ï¼‰ -->
  <div class="toast-container">
    <div id="applyToast" class="toast" role="status" aria-live="polite" aria-atomic="true">
      <div class="toast-header">
        <strong class="me-auto">æ‰€æŒã‚’ä¸Šæ›¸ãã—ã¾ã—ãŸ</strong>
        <small class="text-muted">OCR</small>
        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
      <div class="toast-body"></div>
    </div>
  </div>

  <script>
    // =========================
    // å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼ˆå¤±æ•—æ™‚ã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    // =========================
    const DEFAULT_DATA = {
      weeklyGroups: [
        { id: 'A', label: 'ã‚«ãƒ¬ãƒ¼' },
        { id: 'B', label: 'ã‚µãƒ©ãƒ€' },
        { id: 'C', label: 'ãƒ‡ã‚¶ãƒ¼ãƒˆ' }
      ],
      recipes: [
        { id: 'ã¨ãã›ã‚“ãƒªãƒ³ã‚´ã‚«ãƒ¬ãƒ¼', name: 'ã¨ãã›ã‚“ãƒªãƒ³ã‚´ã‚«ãƒ¬ãƒ¼', group: 'A', slug: 'a-fallback-01', per: { 'ã¨ãã›ã‚“ãƒªãƒ³ã‚´': 7 } }
      ],
      ingredients: [
        { name: 'ã¨ãã›ã‚“ãƒªãƒ³ã‚´', img: 'images/ingredients/apple.png', aliases: [] }
      ]
    };

    let DATASET = null;
    const DATASET_INDEX = { bySlug: Object.create(null), byId: Object.create(null) };

    // é£Ÿæã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆname/aliases â†’ ãƒ¬ã‚³ãƒ¼ãƒ‰ï¼‰& é †åº
    let ING_INDEX = Object.create(null);
    let ING_ORDER = Object.create(null); // name -> indexï¼ˆingredientsé…åˆ—ã®é †ç•ªï¼‰

    // =========================
    // localStorageï¼ˆv1ï¼‰
    // =========================
    const LS = { CART: 'ps-v1-cart', STOCK: 'ps-v1-stock' };

    function saveCartToLS() {
      try {
        const items = [...cart.entries()].map(([slug, { qty }]) => [slug, qty]);
        localStorage.setItem(LS.CART, JSON.stringify({ items }));
      } catch (e) { console.warn('saveCartToLS failed', e); }
    }

    function loadCartFromLS() {
      try {
        const raw = JSON.parse(localStorage.getItem(LS.CART) || '{}');
        const items = raw.items || [];
        const m = new Map();
        for (const [slug, qty] of items) {
          m.set(slug, { qty: Math.max(1, parseInt(qty || '1', 10) || 1) });
        }
        return m;
      } catch (e) { return new Map(); }
    }

    function saveStockToLS() {
      try {
        const entries = [...stock.entries()];
        localStorage.setItem(LS.STOCK, JSON.stringify({ entries }));
      } catch (e) { console.warn('saveStockToLS failed', e); }
    }

    function loadStockFromLS() {
      try {
        const raw = JSON.parse(localStorage.getItem(LS.STOCK) || '{}');
        const entries = raw.entries || [];
        return new Map(entries);
      } catch (e) { return new Map(); }
    }

    // =========================
    // çŠ¶æ…‹
    // =========================
    const cart  = loadCartFromLS(); // Map<slug,{qty}>
    const stock = loadStockFromLS(); // Map<name,have>

    // =========================
    // dataset.json èª­ã¿è¾¼ã¿
    // =========================
    async function loadDataset() {
      try {
        const res = await fetch('dataset.json', { cache: 'no-cache' });
        if (!res.ok) throw new Error('dataset fetch failed');
        const data = await res.json();
        return data;
      } catch (e) {
        console.warn('dataset.json load failed. use DEFAULT_DATA', e);
        return DEFAULT_DATA;
      }
    }

    function buildIndexes(data) {
      DATASET_INDEX.bySlug = Object.create(null);
      DATASET_INDEX.byId   = Object.create(null);
      data.recipes.forEach(r => {
        const slug = r.slug || r.id;
        DATASET_INDEX.bySlug[slug] = r;
        DATASET_INDEX.byId[r.id] = r;
      });

      ING_INDEX = Object.create(null);
      ING_ORDER = Object.create(null);
      data.ingredients.forEach((ing, idx) => {
        const names = [ing.name, ...(ing.aliases || [])].filter(Boolean);
        for (const k of names) ING_INDEX[k] = ing; // name/alias â†’ ãƒ¬ã‚³ãƒ¼ãƒ‰
        ING_ORDER[ing.name] = idx;
      });
    }

    function getRecipeListByGroup(group) {
      const list = DATASET.recipes.filter(r => (r.group || 'A') === group);
      list.sort((a,b) => (a.slug||a.id).localeCompare(b.slug||b.id, 'ja'));
      return list;
    }

    function getRecipeParts(recipe) {
      const per = recipe.per || {};
      return Object.entries(per);
    }

function createIngImg(name, cls='ing-32') {
  const img = document.createElement('img');
  const rec = ING_INDEX[name];
  img.alt = name;
  img.title = name;
  img.className = `ing-img ${cls}`;

  // æ–‡å­—ãƒ™ãƒ¼ã‚¹ã®SVGãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ï¼ˆ404æ™‚ã«å³åº§ã«åˆ‡æ›¿ï¼‰
  const svg = encodeURIComponent(
    `<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'>
      <rect width='100%' height='100%' fill='#f1f3f5'/>
      <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle'
            font-size='10' fill='#6c757d'>${(name||'').slice(0,2)}</text>
    </svg>`
  );
  const fallback = `data:image/svg+xml;charset=utf-8,${svg}`;

  img.src = (rec && rec.img) ? rec.img : fallback;
  img.onerror = () => { img.onerror = null; img.src = fallback; };

  return img;
}


    // =========================
    // G1ï¼ˆé¸æŠ â†’ è¿½åŠ ï¼‰
    // =========================
    let weeklyGroup = 'A';

    function bindGroup1() {
      const radA = document.getElementById('wgA');
      const radB = document.getElementById('wgB');
      const radC = document.getElementById('wgC');
      const select = document.getElementById('recipeSelect');
      const g1Prev = document.getElementById('g1Preview');
      const qtyMinus = document.getElementById('qtyMinus');
      const qtyPlus  = document.getElementById('qtyPlus');
      const qtyInput = document.getElementById('qtyInput');
      const addBtn   = document.getElementById('addBtn');

      const renderGroupLabel = () => {
        const A = DATASET.weeklyGroups.find(g=>g.id==='A');
        const B = DATASET.weeklyGroups.find(g=>g.id==='B');
        const C = DATASET.weeklyGroups.find(g=>g.id==='C');
        if (A) document.getElementById('wgLabelA').textContent = A.label || 'A';
        if (B) document.getElementById('wgLabelB').textContent = B.label || 'B';
        if (C) document.getElementById('wgLabelC').textContent = C.label || 'C';
      };

      const renderSelect = () => {
        select.innerHTML = '';
        const list = getRecipeListByGroup(weeklyGroup);
        const empty = document.createElement('option'); empty.value = ''; empty.textContent = 'â€” æ–™ç†ã‚’é¸æŠ â€”'; select.appendChild(empty);
        for (const r of list) {
          const opt = document.createElement('option');
          opt.value = r.slug || r.id;
          opt.textContent = r.name || r.id;
          select.appendChild(opt);
        }
      };

      const renderPreview = (slug, qty) => {
        g1Prev.innerHTML = '';
        if (!slug) return;
        const r = DATASET_INDEX.bySlug[slug];
        const per = r?.per || {};
        for (const [ing, base] of Object.entries(per)) {
          const chip = document.createElement('span'); chip.className = 'ing-chip border rounded bg-light';
          chip.appendChild(createIngImg(ing, 'ing-28'));
          const txt = document.createElement('span'); txt.textContent = `Ã— ${base * qty}`; txt.className = 'ing-count';
          chip.appendChild(txt);
          g1Prev.appendChild(chip);
        }
      };

      const setQty = (v) => { const n = Math.max(1, parseInt(v||'1',10)||1); qtyInput.value = String(n); return n; };

      radA.addEventListener('change', () => { if (radA.checked) { weeklyGroup = 'A'; renderSelect(); renderPreview(select.value, setQty(qtyInput.value)); } });
      radB.addEventListener('change', () => { if (radB.checked) { weeklyGroup = 'B'; renderSelect(); renderPreview(select.value, setQty(qtyInput.value)); } });
      radC.addEventListener('change', () => { if (radC.checked) { weeklyGroup = 'C'; renderSelect(); renderPreview(select.value, setQty(qtyInput.value)); } });
      select.addEventListener('change', () => renderPreview(select.value, setQty(qtyInput.value)));
      qtyMinus.addEventListener('click', () => renderPreview(select.value, setQty((parseInt(qtyInput.value||'1',10)||1)-1)));
      qtyPlus .addEventListener('click', () => renderPreview(select.value, setQty((parseInt(qtyInput.value||'1',10)||1)+1)));
      qtyInput.addEventListener('input', () => renderPreview(select.value, setQty(qtyInput.value)));

      addBtn.addEventListener('click', () => {
        const slug = select.value; if (!slug) return;
        const q = Math.max(1, parseInt(qtyInput.value||'1',10)||1);
        cart.set(slug, { qty: q });
        renderAll();
        saveCartToLS();
      });

      renderGroupLabel(); renderSelect(); renderPreview('', setQty(qtyInput.value));
    }

    // =========================
    // G2ï¼ˆãƒ¬ã‚·ãƒ”ã‚«ãƒ¼ãƒ‰ï¼‰
    // =========================
    function createCardStepper(initialQty, onLiveChange, onCommit) {
      const group = document.createElement('div');
      group.className = 'input-group input-group-sm stepper-compact';

      const minus = document.createElement('button');
      minus.className = 'btn btn-outline-secondary btn-step';
      minus.type = 'button';
      minus.textContent = 'ï¼';

      const input = document.createElement('input');
      input.className = 'form-control qty-input';
      input.type = 'number'; input.inputMode = 'numeric'; input.pattern = '[0-9]*'; input.min = '1'; input.step = '1'; input.value = String(initialQty);

      const plus = document.createElement('button');
      plus.className = 'btn btn-outline-secondary btn-step';
      plus.type = 'button';
      plus.textContent = 'ï¼‹';

      const clamp = (v) => { const n = parseInt(v || '1', 10); return isNaN(n) ? 1 : Math.max(1, n); };

      const sync = () => { const q = clamp(input.value); input.value = String(q); onLiveChange?.(q); };
      const commit = () => { const q = clamp(input.value); onCommit?.(q); };

      minus.addEventListener('click', () => { input.value = String(Math.max(1, (parseInt(input.value||'1',10)||1) - 1)); sync(); commit(); });
      plus .addEventListener('click', () => { input.value = String((parseInt(input.value||'1',10)||1) + 1); sync(); commit(); });
      input.addEventListener('input', sync);
      input.addEventListener('change', commit);

      group.appendChild(minus); group.appendChild(input); group.appendChild(plus);
      return group;
    }

    function renderRecipeCard(slug, recipeName, qty, recipe) {
      const card = document.createElement('div');
      card.className = 'card';

      const header = document.createElement('div');
      header.className = 'card-header d-flex justify-content-between align-items-center gap-2';

      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = recipeName;

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-sm btn-outline-danger';
      delBtn.textContent = 'Ã—';
      delBtn.addEventListener('click', () => { cart.delete(slug); renderAll(); saveCartToLS(); });

      header.appendChild(title); header.appendChild(delBtn);
      card.appendChild(header);

      const body = document.createElement('div');
      body.className = 'card-body';

      const list = document.createElement('div');
      list.className = 'ing-grid';

      const updateListForQty = (q) => {
        list.innerHTML = '';
        for (const [ing, base] of getRecipeParts(recipe)) {
          const item = document.createElement('div');
          item.className = 'ing-grid-item';
          item.appendChild(createIngImg(ing, 'ing-32'));
          const cnt = document.createElement('span'); cnt.className = 'ing-count'; cnt.textContent = `Ã— ${base * q}`;
          item.appendChild(cnt);
          list.appendChild(item);
        }
      };

      const stepper = createCardStepper(
        qty,
        (liveQty)  => { updateListForQty(liveQty); },
        (commitQty)=> { cart.set(slug, { qty: Math.max(1, commitQty) }); renderTotals(); saveCartToLS(); }
      );

      updateListForQty(qty);

      const ctlRow = document.createElement('div');
      ctlRow.className = 'd-flex flex-wrap align-items-center gap-2 mb-2';
      ctlRow.appendChild(stepper);

      body.appendChild(ctlRow);
      body.appendChild(list);
      card.appendChild(body);

      return card;
    }

    function renderGroup2() {
      const body = document.getElementById('group2Body');
      body.innerHTML = '';

      if (cart.size === 0) {
        const p = document.createElement('p');
        p.className = 'empty-hint m-0';
        p.textContent = 'ã¾ã æ–™ç†ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€Œè¿½åŠ ã€ã§æŠ•å…¥ã—ã¦ãã ã•ã„ã€‚';
        body.appendChild(p);
        return;
      }

      const grid = document.createElement('div');
      grid.className = 'row g-3';

      for (const [slug, { qty }] of cart) {
        const r = DATASET_INDEX.bySlug[slug];
        const col = document.createElement('div');
        col.className = 'col-12';
        col.appendChild(renderRecipeCard(slug, r.name, qty, r));
        grid.appendChild(col);
      }
      body.appendChild(grid);
    }

    function bindClearAll() {
      const clearBtn = document.getElementById('clearAllBtn');
      if (!clearBtn) return;
      clearBtn.addEventListener('click', () => {
        if (cart.size === 0) return;
        if (!confirm('æœ¬å½“ã«å…¨å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
        cart.clear();
        renderAll();
        saveCartToLS();
      });
    }

    // =========================
    // G3ï¼ˆé›†è¨ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼æ‰€æŒå…¥åŠ›ï¼‰
    // =========================
    function renderTotals() {
      const tbody = document.querySelector('#totalTable tbody');
      const empty = document.getElementById('totalEmpty');
      const resetBtn = document.getElementById('resetStockBtn');
      tbody.innerHTML = '';

      if (cart.size === 0) {
        empty.style.display = '';
        if (resetBtn) resetBtn.disabled = true;
        return;
      }
      empty.style.display = 'none';
      if (resetBtn) resetBtn.disabled = false;

      // é›†è¨ˆï¼šingredient -> needTotalï¼ˆé­é‡é †ã‚‚ä¿æŒï¼‰
      const needMap = new Map();
      const encounterOrder = new Map();
      let seq = 0;
      for (const [slug, { qty }] of cart) {
        const per = DATASET_INDEX.bySlug[slug].per || {};
        for (const [ing, base] of Object.entries(per)) {
          if (!encounterOrder.has(ing)) encounterOrder.set(ing, seq++);
          needMap.set(ing, (needMap.get(ing) || 0) + base * qty);
        }
      }

      for (const ing of needMap.keys()) if (!stock.has(ing)) stock.set(ing, 0);

      const rowsKnown = [];
      const rowsUnknown = [];
      for (const [ing, need] of needMap.entries()) {
        const idx = ING_ORDER[ing];
        if (typeof idx === 'number') rowsKnown.push({ ing, need, idx });
        else rowsUnknown.push({ ing, need, ord: encounterOrder.get(ing) });
      }
      rowsKnown.sort((a,b) => a.idx - b.idx);
      rowsUnknown.sort((a,b) => a.ord - b.ord);
      const rows = rowsKnown.concat(rowsUnknown);

      for (const row of rows) {
        const { ing, need } = row;
        const tr = document.createElement('tr');
        tr.dataset.ing = ing;

        const tdIng = document.createElement('td');
        const ingWrap = document.createElement('div'); ingWrap.className = 'd-flex align-items-center gap-2';
        ingWrap.appendChild(createIngImg(ing, 'ing-28'));
        const label = document.createElement('span'); label.className = 'ing-label-minitext'; label.textContent = ing; // G3ã®ã¿æ¥µå°ãƒ©ãƒ™ãƒ«
        ingWrap.appendChild(label);
        tdIng.appendChild(ingWrap);

        const tdNeed = document.createElement('td'); tdNeed.textContent = String(need);

        const tdHave = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'number'; input.className = 'form-control form-control-sm w-6ch';
        input.min = '0'; input.step = '1'; input.inputMode = 'numeric'; input.pattern = '[0-9]*';
        input.value = String(stock.get(ing) || 0);
        tdHave.appendChild(input);

        const tdLack = document.createElement('td');
        tdLack.textContent = String(Math.max(need - (stock.get(ing) || 0), 0));

        input.addEventListener('input', () => {
          let v = parseInt(input.value || '0', 10);
          if (isNaN(v) || v < 0) v = 0;
          input.value = String(v);
          stock.set(ing, v);
          tdLack.textContent = String(Math.max(need - v, 0));
          saveStockToLS();
        });

        tr.appendChild(tdIng); tr.appendChild(tdNeed); tr.appendChild(tdHave); tr.appendChild(tdLack);
        tbody.appendChild(tr);
      }
    }

    // åœ¨åº«ã‚¯ãƒªã‚¢
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('#resetStockBtn');
      if (!btn) return;
      if (!confirm('åœ¨åº«ã‚’0ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;
      stock.clear();
      renderTotals();
      saveStockToLS();
    });

    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæç”»
    function renderAll() {
      renderGroup2();
      renderTotals();

      const g2 = document.getElementById('group2Card');
      const clearBtn = document.getElementById('clearAllBtn');
      if (cart.size === 0) {
        g2.classList.add('d-none');
        if (clearBtn) clearBtn.disabled = true;
      } else {
        g2.classList.remove('d-none');
        if (clearBtn) clearBtn.disabled = false;
      }
    }

    // =========================
    // OCRï¼ˆã‚«ãƒ¡ãƒ©UIçµ±åˆãƒ»ä¸Šæ›¸ãåæ˜ ï¼‰
    // =========================
    const OCR = {
      status: null, out: null, debug: false,
      W_NAME: null, W_DIG: null, langReady: false, loading: false,
    };

const OCR_CONST = {
  MAX_DIST: 3,                         // åå‰ãƒãƒƒãƒè·é›¢ã®ä¸Šé™
  AUTO_APPLY_DIST_MAX: 1,              // è‡ªå‹•ä¸Šæ›¸ãã«è¨±å®¹ã™ã‚‹æœ€å¤§è·é›¢
  AUTO_CONFIRM_QTY_MIN: 300,           // â˜…ã“ã®æ•°é‡ä»¥ä¸Šã¯ç¢ºèªã¸ï¼ˆè‡ªå‹•ä¸Šæ›¸ãã—ãªã„ï¼‰
  RETRY_SCALES: [0.75, 1.0, 1.25, 1.5], // +0,+33,+50,-25,-33,-50%
  COLS: 4,                             // åˆ—ã¯å›ºå®š
  ROWS_MIN: 1, ROWS_MAX: 4, ROWS_DEF: 4,
  THUMB_W: 40
};

// === OCRå®Ÿè¡Œå‰ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ & ãƒœã‚¿ãƒ³åˆ¶å¾¡ï¼ˆUNDOç”¨ï¼‰ ===
let PRE_OCR_SNAPSHOT = null;       // [{ ing, val }, ...] ã‚’ä¿æŒ

function getOcrRunButton(){
  // æ—¢å­˜IDã‚„dataå±æ€§ã«åºƒã‚ã«å¯¾å¿œ
  return document.querySelector(
    '#btnOcrRun, [data-action="ocr-run"], button[data-ocr-run], #btnCameraRun, button#runOcr'
  );
}

function setRunButtonEnabled(enabled){
  const btn = getOcrRunButton();
  if (!btn) return;
  btn.disabled = !enabled;
  btn.classList.toggle('disabled', !enabled);
}

function captureStockSnapshot(){
  const snap = [];
  (DATASET.ingredients || []).forEach(rec => {
    const input = findStockInputByName(rec.name);
    if (input) {
      const val = parseInt(input.value || '0', 10) || 0;
      snap.push({ ing: rec.name, val });
    }
  });
  return snap;
}

function applyStockSnapshot(snap){
  if (!Array.isArray(snap)) return 0;
  let cnt = 0;
  for (const it of snap){
    const input = findStockInputByName(it.ing);
    if (!input) continue;
    input.value = String(it.val);
    input.dispatchEvent(new Event('input', { bubbles: true }));
    cnt++;
  }
  return cnt;
}

// === å®Ÿè¡Œå¾Œãƒˆãƒ¼ã‚¹ãƒˆï¼ˆ3ç§’è¡¨ç¤ºãƒ»å…ƒã«æˆ»ã™=S1 å¼·åˆ¶å¾©å…ƒï¼‰ ===
let OCR_TOAST_TIMER = null;

function showUndoToastAfterRun(){
  // ãƒˆãƒ¼ã‚¹ãƒˆç½®å ´
  let area = document.getElementById('toastArea');
  if (!area) {
    area = document.createElement('div');
    area.id = 'toastArea';
    area.className = 'position-fixed bottom-0 end-0 p-3';
    area.style.zIndex = '1080';
    document.body.appendChild(area);
  }
  // æ—¢å­˜ãƒˆãƒ¼ã‚¹ãƒˆãŒã‚ã‚Œã°æ¶ˆã™ï¼ˆå¸¸ã«1ã¤ï¼‰
  area.innerHTML = '';

  const toast = document.createElement('div');
  toast.className = 'toast show border-0 shadow-sm';
  toast.setAttribute('role','status');
  toast.setAttribute('aria-live','polite');
  toast.setAttribute('aria-atomic','true');
  toast.innerHTML = `
    <div class="toast-body d-flex align-items-center gap-3">
      <span>ä¸Šæ›¸ãã—ã¾ã—ãŸ</span>
      <button type="button" class="btn btn-sm btn-outline-secondary ms-auto" id="undoAll">å…ƒã«æˆ»ã™</button>
    </div>`;
  area.appendChild(toast);

  const finish = () => {
    if (OCR_TOAST_TIMER) { clearTimeout(OCR_TOAST_TIMER); OCR_TOAST_TIMER = null; }
    toast.classList.remove('show'); toast.classList.add('hide');
    setTimeout(()=>{ toast.remove(); }, 200);
    // 3ç§’çµŒé or Undoå¾Œã¯ãƒœã‚¿ãƒ³ã‚’å†æœ‰åŠ¹åŒ–
    setRunButtonEnabled(true);
  };

  // Undoï¼šOCRå®Ÿè¡Œå‰ã®çŠ¶æ…‹ã«å¼·åˆ¶å¾©å…ƒï¼ˆS1ï¼‰
  toast.querySelector('#undoAll').addEventListener('click', () => {
    try {
      const n = applyStockSnapshot(PRE_OCR_SNAPSHOT);
      addHistoryLine(`å…ƒã«æˆ»ã™: èª­å–å‰ã®çŠ¶æ…‹ã¸å¾©å…ƒï¼ˆ${n}é …ç›®ï¼‰`);
      // ç¢ºèªãƒ‘ãƒãƒ«ãŒé–‹ã„ã¦ã„ã‚Œã°é–‰ã˜ã‚‹
      const panel = document.getElementById('confirmPanel');
      if (panel){ panel.innerHTML=''; panel.classList.add('d-none'); }
    } catch(e){ console.warn(e); }
    finally {
      PRE_OCR_SNAPSHOT = null;
      finish();
    }
  });

  // 3ç§’ã§è‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚º
  OCR_TOAST_TIMER = setTimeout(() => {
    PRE_OCR_SNAPSHOT = null;
    finish();
  }, 3000);
}


    // ç”»åƒã‚°ãƒªãƒƒãƒ‰æ—¢å®šï¼ˆå·¦ãƒ»ä¸Šãƒ»ã‚¿ã‚¤ãƒ«W/Hãƒ»gapX/Yãƒ»è¡Œåˆ—ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»yOffsetï¼‰
    const DEFAULT_GRID = {
      cols: 4, rows: 4,
      left: 50, top: 510,
      tileW: 225, tileH: 340, // tileH ã¯ä»Šã¯å›ºå®šï¼ˆå°†æ¥ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ä½™åœ°ï¼‰
      gapX: 24, gapY: 38,
      scale: 2, yOffset: 0
    };
    const DEFAULT_BOTTOM = DEFAULT_GRID.top + (DEFAULT_GRID.rows - 1) * (DEFAULT_GRID.tileH + DEFAULT_GRID.gapY) + DEFAULT_GRID.tileH;

    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    const cssEscape = (s)=> s.replace(/\"/g,'\\"');
    const normalizeKey = (s)=> String(s||'')
      .replace(/[\s\u3000]/g,'')
      .replace(/[Ã—âœ•xXï¼Š*Â·ãƒ»]/g,'x')
      .replace(/[()ï¼ˆï¼‰\[\]ã€ã€‘]/g,'')
      .trim();

// å…¨è§’æ•°å­—ã‚’åŠè§’ã¸ï¼ˆ"ï¼‘ï¼’ï¼“" â†’ "123"ï¼‰
function toHalfWidthDigits(s){
  return String(s||'').replace(/[ï¼-ï¼™]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
}

    function computeTopFromBottom(rows){
      rows = Math.max(OCR_CONST.ROWS_MIN, Math.min(OCR_CONST.ROWS_MAX, Number(rows) || DEFAULT_GRID.rows));
      const tileH = DEFAULT_GRID.tileH; // ã„ã¾ã¯å›ºå®š
      const gapY  = DEFAULT_GRID.gapY;
      const stepY = tileH + gapY;
      return Math.round(DEFAULT_BOTTOM - tileH - (rows - 1) * stepY);
    }

    // gapX ã®ã‚¯ãƒ©ãƒ³ãƒ—ï¼ˆç”»åƒå¹…ãƒ»åˆ—æ•°ãƒ»ã‚¿ã‚¤ãƒ«å¹…ãƒ»left ã‹ã‚‰ç®—å‡ºï¼‰
    function getGapXClamp(imgWidth, p){
      let max;
      if (p.cols <= 1){
        max = Math.max(0, Math.floor(imgWidth - p.left - p.tileW));
      } else {
        const numer = imgWidth - p.left - p.tileW * p.cols;
        max = Math.floor(numer / Math.max(1, (p.cols - 1)));
        if (!Number.isFinite(max) || max < 0) max = 0;
      }
      return { min: 0, max };
    }

    // yOffset ã®ã‚¯ãƒ©ãƒ³ãƒ—ï¼ˆç”»é¢é«˜ã•ã«å¯¾ã™ã‚‹å®‰å…¨ç¯„å›²ï¼‰
    function getYOffsetClamp(imgHeight, p){
      const baseTop = computeTopFromBottom(p.rows);
      const min = Math.max(-Math.floor(p.tileH*0.5), -baseTop); // ä¸Šã¸è¡Œãã™ãé˜²æ­¢
      const bottom = baseTop + (p.rows-1)*(p.tileH+p.gapY) + p.tileH;
      const max = Math.min(Math.floor(p.tileH*0.5), Math.max(0, imgHeight - bottom));
      return { min, max };
    }

    // UIå€¤ã‚’ãƒ‘ãƒ©ãƒ¡ã‚¿åŒ–
    let gridRowCount = OCR_CONST.ROWS_DEF;
    function getGridParamsFromUI(){
      return {
        cols: DEFAULT_GRID.cols,
        rows: gridRowCount,
        left: DEFAULT_GRID.left,
        top: computeTopFromBottom(gridRowCount) + DEFAULT_GRID.yOffset + Number(document.getElementById('cameraSlider2')?.dataset.yofs||0),
        tileW: DEFAULT_GRID.tileW,
        tileH: DEFAULT_GRID.tileH,
        gapX: Number(document.getElementById('cameraSlider1')?.dataset.gapx||DEFAULT_GRID.gapX),
        gapY: DEFAULT_GRID.gapY,
        scale: DEFAULT_GRID.scale,
        yOffset: Number(document.getElementById('cameraSlider2')?.dataset.yofs||0)
      };
    }

    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ç”»åƒä¾å­˜ã® min/max ã‚’åæ˜ 
    function applyGapXClampToUI(img, p){
      const el = document.getElementById('cameraSlider1'); if(!el) return;
      const clamp = getGapXClamp(img.width, p);
      el.min = '0';
      el.max = '100';
      // 0..100 ã‚’ clamp.min..clamp.max ã«å°„å½±
      const cur = Number(el.value||'50');
      const mapped = Math.round(clamp.min + (clamp.max - clamp.min) * (cur/100));
      el.dataset.gapx = String(mapped);
      el.title = `gapX: ${mapped} (min:${clamp.min}, max:${clamp.max})`;
    }
    function applyYOffsetClampToUI(img, p){
      const el = document.getElementById('cameraSlider2'); if(!el) return;
      const clamp = getYOffsetClamp(img.height, p);
      el.min = '0'; el.max = '100';
      const cur = Number(el.value||'50');
      const mapped = Math.round(clamp.min + (clamp.max - clamp.min) * (cur/100));
      el.dataset.yofs = String(mapped);
      el.title = `yOffset: ${mapped} (min:${clamp.min}, max:${clamp.max})`;
    }

    // ç”»åƒèª­è¾¼
    function loadImageAny(fileOrUrl){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=> resolve(img);
        img.onerror = (e)=> reject(new Error('image load error'));
        if (fileOrUrl instanceof File) img.src = URL.createObjectURL(fileOrUrl);
        else img.src = String(fileOrUrl);
      });
    }


    // ã‚­ãƒ£ãƒ³ãƒã‚¹åˆ‡ã‚Šå‡ºã—
    function extractTileCanvas(img, p, r, c){
      const sx = p.left + c * (p.tileW + p.gapX);
      const sy = p.top  + r * (p.tileH + p.gapY);
      const canvas = document.createElement('canvas');
      canvas.width = p.tileW * p.scale; canvas.height = p.tileH * p.scale;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, sx, sy, p.tileW, p.tileH, 0, 0, canvas.width, canvas.height);
      return canvas;
    }

    // ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆ
    let __lastFile = null;
    async function buildTileThumbnails(file){
      if(!file) return;
      const p   = getGridParamsFromUI();
      const img = await loadImageAny(file);
      applyGapXClampToUI(img, p);
      applyYOffsetClampToUI(img, p);
      const pClamped = getGridParamsFromUI();

      const wrap = document.getElementById('tileThumbs');
      const best = document.getElementById('bestLine');
      if (wrap) wrap.innerHTML = '';
      if (best) best.textContent = '';

      const stepX = pClamped.tileW + pClamped.gapX;
      const stepY = pClamped.tileH + pClamped.gapY;
      const usableW = Math.max(0, img.width - pClamped.left + pClamped.gapX);
      const maxCols = Math.max(1, Math.floor(usableW / stepX));
      const effCols = Math.min(pClamped.cols, maxCols);

      const scale = Math.max(0.05, Math.min(1, OCR_CONST.THUMB_W / pClamped.tileW));
      const tc = document.createElement('canvas');
      tc.width  = Math.round(pClamped.tileW * scale);
      tc.height = Math.round(pClamped.tileH * scale);
      const tctx = tc.getContext('2d'); tctx.imageSmoothingEnabled = true; tctx.imageSmoothingQuality='high';

      let tileIndex = 0;
      for (let r=0; r<pClamped.rows; r++){
        for (let c=0; c<effCols; c++){
          tctx.clearRect(0,0,tc.width,tc.height);
          const sx = pClamped.left + c * stepX;
          const sy = pClamped.top  + r * stepY;
          tctx.drawImage(img, sx, sy, pClamped.tileW, pClamped.tileH, 0, 0, tc.width, tc.height);
          const thumb = new Image(); thumb.src = tc.toDataURL('image/png');
          thumb.alt = `tile ${++tileIndex}`; thumb.title = `tile ${tileIndex} (row ${r+1}, col ${c+1})`;
          thumb.className = 'tile-thumb';
          wrap?.appendChild(thumb);
        }
      }
    }

    // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
    function setDebugLines(lines){
      const dbg = document.getElementById('ocrDebug');
      const pre = document.getElementById('debugPre');
      if (!dbg || !pre) return;
      if (!OCR.debug){ dbg.style.display='none'; return; }
      dbg.style.display='';
      pre.textContent = lines || '';
    }

    // ---- Tesseract æº–å‚™ ----
async function ensureTesseract(){
  if (OCR.loading) { while(!OCR.langReady) await new Promise(r=>setTimeout(r,60)); return; }
  if (OCR.langReady) return;
  OCR.loading = true;
  try {
    const CDN = {
      esm:   'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.esm.min.js',
      umd:   'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js',
      worker:'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/worker.min.js',
      core:  'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.0/tesseract-core.wasm.js',
      lang:  'https://tessdata.projectnaptha.com/4.0.0'
    };

    let TesseractNS = (typeof window !== 'undefined') ? window.Tesseract : undefined;
    if (!TesseractNS) {
      try { const mod = await import(CDN.esm); TesseractNS = mod?.default || mod; } catch(_) {}
    }
    if (!TesseractNS || typeof TesseractNS.createWorker !== 'function') {
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = CDN.umd; s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('failed to load tesseract.min.js'));
        document.head.appendChild(s);
      });
      TesseractNS = window.Tesseract;
    }
    const createWorker = TesseractNS?.createWorker;
    if (typeof createWorker !== 'function') throw new Error('Unable to acquire Tesseract.createWorker');

    const OPTS = { workerPath: CDN.worker, corePath: CDN.core, langPath: CDN.lang };

    // æ—¥æœ¬èªï¼ˆåå‰ï¼‰â€” å˜ä¸€è¡Œ
    OCR.W_NAME = await createWorker('jpn', undefined, OPTS);
    await OCR.W_NAME.setParameters({
      tessedit_char_blacklist: '0123456789',
      tessedit_pageseg_mode: 7
    });

    // è‹±èªï¼ˆæ•°å­—ï¼‰â€” å˜ä¸€è¡Œï¼xè¨˜å·ã‚‚è¨±å®¹ï¼ˆå¾“æ¥ã©ãŠã‚Šï¼‰
    OCR.W_DIG  = await createWorker('eng', undefined, OPTS);
    await OCR.W_DIG.setParameters({
      tessedit_char_whitelist: '0123456789xXÃ—âœ•',
      tessedit_pageseg_mode: 7,
      classify_bln_numeric_mode: 1
    });

    OCR.langReady = true;
  } finally {
    OCR.loading = false;
  }
}

    // æ–‡å­—åˆ—è·é›¢ï¼ˆéƒ¨åˆ†è·é›¢ã®æœ€å°ï¼šåå‰â†’å€™è£œï¼‰
    function levenshtein(a,b){
      const m=a.length, n=b.length; if (!m) return n; if (!n) return m;
      const dp=Array.from({length:m+1},()=>new Array(n+1).fill(0));
      for (let i=0;i<=m;i++) dp[i][0]=i; for (let j=0;j<=n;j++) dp[0][j]=j;
      for (let i=1;i<=m;i++){
        const ca=a.charCodeAt(i-1);
        for (let j=1;j<=n;j++){
          const cb=b.charCodeAt(j-1);
          const cost = (ca===cb)?0:1; // ç½®æ›
          dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
        }
      }
      return dp[m][n];
    }
    function minSubstrDistance(text, key){
      if (!text||!key) return Infinity;
      const t = normalizeKey(text), k = normalizeKey(key);
      if (!t||!k) return Infinity;
      let best = Infinity;
      for (let i=0; i<=t.length-k.length; i++){
        const sub = t.slice(i, i+k.length);
        const d = levenshtein(sub, k);
        if (d < best) best = d;
        if (best === 0) break;
      }
      return best;
    }

    // é£Ÿæåã‚ã„ã¾ã„ãƒãƒƒãƒï¼ˆãƒˆãƒ¼ã‚¯ãƒ³æŠ•ç¥¨ï¼‹éƒ¨åˆ†è·é›¢ï¼‰
    let ING_FULL_KEYS = [];
    let KEYWORD_INDEX = new Map(); // token â†’ Set<ingId>

    function buildIngredientMatchers(){
      const list = DATASET.ingredients || [];
      ING_FULL_KEYS = list.map(i=> normalizeKey(i.name));
      KEYWORD_INDEX = new Map();
      list.forEach((ing, id)=>{
        const all = [ing.name, ...(ing.aliases||[])];
        for (const s of all){
          String(s).split(/[^\wã-ã‚”ã‚¡-ãƒ´ãƒ¼ä¸€-é¾ ]+/).map(x=>normalizeKey(x)).filter(x=>x.length>=2)
            .forEach(tok=>{
              if (!KEYWORD_INDEX.has(tok)) KEYWORD_INDEX.set(tok, new Set());
              KEYWORD_INDEX.get(tok).add(id);
            });
        }
      });
    }

    function matchIngredientByTokens(tokens, compactText){
      const votes = new Map();
      for (const t of tokens){
        const s = normalizeKey(t);
        const ids = KEYWORD_INDEX.get(s);
        if (!ids) continue;
        ids.forEach(id => votes.set(id, (votes.get(id)||0) + 1));
      }
      if (votes.size){
        let bestId=null, bestVote=-1, bestDist=Infinity;
        for (const [id, v] of votes){
          const full = ING_FULL_KEYS[id] || '';
          const d = minSubstrDistance(compactText||'', full||'');
          if (v > bestVote || (v===bestVote && d < bestDist)){
            bestId = id; bestVote = v; bestDist = d;
          }
        }
        if (bestDist <= OCR_CONST.MAX_DIST) return { id: bestId, votes: bestVote, dist: bestDist };
      }
      // è·é›¢ã®ã¿å…¨æ¢ç´¢
      const text = compactText||'';
      let pickId=null, pickD=Infinity;
      for (let id=0; id<ING_FULL_KEYS.length; id++){
        const d = minSubstrDistance(text, ING_FULL_KEYS[id]);
        if (d < pickD){ pickD=d; pickId=id; if (d===0) break; }
      }
      if (pickD<=OCR_CONST.MAX_DIST) return { id: pickId, votes: 0, dist: pickD };
      return null;
    }

    // ã‚¿ã‚¤ãƒ«OCRï¼ˆåå‰ï¼‹æ•°é‡ï¼‰ï¼šæ•°é‡ã¯è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€Œä¸æ¡ç”¨ã€
async function recognizeTile(tileCanvas, up=1.0){
  let inputCanvas = tileCanvas;
  if (up > 1.01){
    const UP_CAP = 3.0; // ç«¯æœ«ä¿è­·
    const f = Math.min(up, UP_CAP);
    const upW = Math.round(tileCanvas.width  * f);
    const upH = Math.round(tileCanvas.height * f);
    const can  = document.createElement('canvas');
    can.width = upW; can.height = upH;
    const ctx = can.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tileCanvas, 0, 0, tileCanvas.width, tileCanvas.height, 0, 0, upW, upH);
    inputCanvas = can;
  }
  const dataURL = inputCanvas.toDataURL('image/png');

  // â˜… ä¸¦åˆ—ã§å®Ÿè¡Œï¼ˆåå‰ãƒ»æ•°å­—ï¼‰
  const [r1, r2] = await Promise.all([
    OCR.W_NAME.recognize(dataURL),
    OCR.W_DIG .recognize(dataURL)
  ]);

  const rawName  = r1.data.text || '';
  const rawDigit = r2.data.text || '';
  const nameNoSp = normalizeKey(rawName);
  const digitNoSp= normalizeKey(rawDigit);

  const tokens = rawName
    .replace(/[Ã—âœ•xX]/g, ' ')
    .replace(/[^ä¸€-é¾ ã-ã‚”ã‚¡-ãƒ´ãƒ¼a-zA-Z0-9]/g, ' ')
    .split(/\s+/)
    .map(s=>normalizeKey(s))
    .filter(s=>s.length>=2);
  const m = matchIngredientByTokens(tokens, nameNoSp);

// æ•°é‡æŠ½å‡ºï¼ˆå„ªå…ˆé †ï¼šrawDigit ã®ã€Œx + æ•°å­—ã€â†’ rawName ã®ã€Œx + æ•°å­—ã€â†’ æ•°å­—å˜ç‹¬ï¼‰
let qty = 0;
// å…¨è§’â†’åŠè§’ã€ã‚¹ãƒšãƒ¼ã‚¹æ­£è¦åŒ–ï¼ˆå…¨è§’ã‚¹ãƒšãƒ¼ã‚¹å«ã‚€ï¼‰
const rdNorm = toHalfWidthDigits(rawDigit).replace(/\u3000/g,' ').replace(/\s+/g,' ').trim();
const rnNorm = toHalfWidthDigits(rawName ).replace(/\u3000/g,' ').replace(/\s+/g,' ').trim();

// 1) "x"ï¼ˆÃ—/âœ•å«ã‚€ï¼‰ã®ç›´å¾Œã®æ•°å­—ï¼ˆ1ã€œ3æ¡ï¼‰ã‚’æœ€å„ªå…ˆ
let mQty = rdNorm.match(/[xÃ—âœ•]\s*([0-9]{1,3})/i);
if (!mQty) mQty = rnNorm.match(/[xÃ—âœ•]\s*([0-9]{1,3})/i);

if (mQty && mQty[1]) {
  qty = parseInt(mQty[1], 10) || 0;
} else {
  // 2) ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šrawDigit å†…ã®æ•°å­—åˆ—ï¼ˆ1ã€œ3æ¡ï¼‰ã‹ã‚‰ã€Œæ¡ãŒé•·ã„æ–¹ã€ã‚’å„ªå…ˆ
  const nums = [...rdNorm.matchAll(/\b([0-9]{1,3})\b/g)].map(n => n[1]);
  if (nums.length) {
    nums.sort((a,b) => b.length - a.length); // 3æ¡ > 2æ¡ > 1æ¡
    qty = parseInt(nums[0], 10) || 0;
  }
}


  // â˜… ãƒ‡ãƒãƒƒã‚°ONæ™‚ã«ç”Ÿæ–‡å­—åˆ—ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ï¼ˆå€ç‡ã‚‚è¡¨ç¤ºï¼‰
  if (OCR.debug) {
    try {
      const rn = (rawName  || '').replace(/\n/g, ' ');
      const rd = (rawDigit || '').replace(/\n/g, ' ');
      console.log(`[OCR][RAW] scale=${up}  name="${rn}"  digit="${rd}"`);
    } catch (_) {}
  }

  const bestName = (m!=null) ? (DATASET.ingredients[m.id]?.name || null) : null;
  return { best: m, bestName, qty, rawName, rawDigit, tokens, nameNoSp, digitNoSp };
}

function findStockInputByName(name){
      const row = document.querySelector(`#totalTable tr[data-ing="${cssEscape(name)}"]`);
      return row ? row.querySelector('input[type=number]') : null;
    }

// å³ä¸‹ãƒˆãƒ¼ã‚¹ãƒˆï¼šå¸¸ã«ã€Œä¸Šæ›¸ãã—ã¾ã—ãŸã€ã ã‘è¡¨ç¤º
function showToastApply(/* ing, qty, source */){
  try {
    // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚’æµç”¨ or ãªã‘ã‚Œã°ä½œæˆ
    let area = document.getElementById('toastArea');
    if (!area) {
      area = document.createElement('div');
      area.id = 'toastArea';
      area.className = 'position-fixed bottom-0 end-0 p-3';
      area.style.zIndex = '1080';
      document.body.appendChild(area);
    }

    // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒˆãƒ¼ã‚¹ãƒˆã‚’ç”Ÿæˆï¼ˆBootstrapæœ‰ç„¡ã‚’å•ã‚ãšå‹•ãæœ€å°æ§‹æˆï¼‰
    const t = document.createElement('div');
    t.className = 'toast show border-0 shadow-sm';
    t.setAttribute('role','status');
    t.setAttribute('aria-live','polite');
    t.setAttribute('aria-atomic','true');
    t.innerHTML = `<div class="toast-body">ä¸Šæ›¸ãã—ã¾ã—ãŸ</div>`;

    area.appendChild(t);

    // 1.4ç§’ã§è‡ªå‹•æ¶ˆå»ï¼ˆæ—¢å­˜ã®æŒ™å‹•ã«åˆã‚ã›ã¦çŸ­ã‚ï¼‰
    setTimeout(() => {
      t.classList.remove('show'); // è¦‹ãŸç›®ã ã‘æ¶ˆã™
      t.classList.add('hide');
      // å°‘ã—å¾…ã£ã¦ã‹ã‚‰DOMã‹ã‚‰é™¤å»
      setTimeout(() => { t.remove(); }, 300);
    }, 1400);
  } catch (e) {
    // ä¸‡ãŒä¸€DOMç”Ÿæˆã«å¤±æ•—ã—ãŸæ™‚ã¯ãƒ­ã‚°ã«ã®ã¿å‡ºã™
    console.log('ä¸Šæ›¸ãã—ã¾ã—ãŸ');
  }
}


    function addHistoryLine(msg){ /* å°†æ¥ï¼šå±¥æ­´UIã«æ‹¡å¼µä½™åœ° */ console.log('[HIST]', msg); }

function renderConfirmPanelUnified(items){
  const root = document.getElementById('confirmPanel');
  if (!root) return;
  root.innerHTML = '';

  if (!items || !items.length) { root.classList.add('d-none'); return; }

  const card = document.createElement('div');
  card.className = 'card';

  // Header
  const hd = document.createElement('div');
  hd.className = 'card-header d-flex align-items-center justify-content-between';
  const title = document.createElement('div');
  title.innerHTML = `<strong>ç¢ºèªï¼ˆæœªè‡ªå‹•é©ç”¨ï¼‰</strong> <small class="text-muted">${items.length}ä»¶</small>`;
  const discardAllBtn = document.createElement('button');
  discardAllBtn.className = 'btn btn-sm btn-outline-secondary';
  discardAllBtn.textContent = 'å…¨éƒ¨ç ´æ£„';
  discardAllBtn.addEventListener('click', () => { list.innerHTML = ''; root.classList.add('d-none'); });
  hd.appendChild(title); hd.appendChild(discardAllBtn);
  card.appendChild(hd);

  // Bodyï¼ˆã‚·ãƒ³ãƒ—ãƒ«åˆ—æŒ™ï¼‰
  const body = document.createElement('div');
  body.className = 'card-body p-2';

  const list = document.createElement('div');
  list.className = 'list-group';

  const buildIngSelect = (defaultName) => {
    const sel = document.createElement('select');
    sel.className = 'form-select form-select-sm';
    const ph = document.createElement('option');
    ph.value = ''; ph.textContent = 'â€” é£Ÿæã‚’é¸æŠ â€”';
    sel.appendChild(ph);
    (DATASET.ingredients || []).forEach(rec => {
      const opt = document.createElement('option');
      opt.value = rec.name; opt.textContent = rec.name;
      if (defaultName && defaultName === rec.name) opt.selected = true;
      sel.appendChild(opt);
    });
    return sel;
  };

  items.forEach((t, idx) => {
    const row = document.createElement('div');
    row.className = 'list-group-item d-flex align-items-center gap-2';
    row.dataset.idx = String(idx);

    // thumb
    const thumb = new Image();
    thumb.src = t.thumb; thumb.alt = 'tile';
    thumb.className = 'tile-thumb';
    row.appendChild(thumb);

    // é£Ÿæåï¼ˆç¢ºå®šâ†’ãƒ©ãƒ™ãƒ« / ä¸æ˜â†’ã‚»ãƒ¬ã‚¯ãƒˆï¼‰
    let ingFixed = !!t.bestName && t.bestDist <= (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1);
    let ingName = t.bestName || '';

    let ingNode;
    if (ingFixed) {
      ingNode = document.createElement('span');
      ingNode.className = 'badge badge-soft';
      ingNode.textContent = ingName;
    } else {
      ingNode = buildIngSelect(ingName || '');
      ingNode.style.minWidth = '180px';
    }
    row.appendChild(ingNode);

    // æ•°é‡
    const qtyInput = document.createElement('input');
    qtyInput.type = 'number';
    qtyInput.className = 'form-control form-control-sm w-6ch';
    qtyInput.min = '0'; qtyInput.step = '1';
    qtyInput.value = String(Math.max(0, parseInt(t.qty || '0', 10) || 0));
    row.appendChild(qtyInput);

    // ç ´æ£„ï¼ˆå³ç«¯ã¸ï¼‰
    const trash = document.createElement('button');
    trash.className = 'btn btn-sm btn-outline-secondary ms-auto';
    trash.textContent = 'ç ´æ£„';
    trash.addEventListener('click', () => { row.remove(); if (!list.querySelector('.list-group-item')) root.classList.add('d-none'); });
    row.appendChild(trash);

    // ãƒ‡ãƒ¼ã‚¿å–å¾—
    row.__getResolved = () => {
      const ingResolved = (ingNode.tagName === 'SELECT') ? ingNode.value : ingName;
      const q = parseInt(qtyInput.value || '0', 10) || 0;
      return { ing: ingResolved, qty: q };
    };

    list.appendChild(row);
  });

  body.appendChild(list);
  card.appendChild(body);

  // Footerï¼ˆä¸€æ‹¬ä¸Šæ›¸ãï¼‰
  const ft = document.createElement('div');
  ft.className = 'card-footer text-end';
  const applyBtn = document.createElement('button');
  applyBtn.className = 'btn btn-sm btn-primary';
  applyBtn.textContent = 'ä¸Šæ›¸ãï¼ˆã™ã¹ã¦ï¼‰';
applyBtn.addEventListener('click', () => {
  const rows = [...list.querySelectorAll('.list-group-item')];
  let applied = 0;
  for (const row of rows) {
    const { ing, qty } = row.__getResolved?.() || {};
    if (!ing || !(Number.isFinite(qty) && qty > 0)) continue;
    const input = findStockInputByName(ing);
    if (!input) continue;
    const prev = parseInt(input.value || '0', 10) || 0;
    input.value = String(qty);
    input.dispatchEvent(new Event('input', { bubbles: true }));
    applied++;
  }
  if (applied > 0) addHistoryLine(`ä¸€æ‹¬ä¸Šæ›¸ã: ${applied}ä»¶ (confirm unified)`);
  root.classList.add('d-none');
});

  ft.appendChild(applyBtn);
  card.appendChild(ft);

  root.appendChild(card);
  root.classList.remove('d-none');
}

// OCRãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ï¼ˆå€ç‡ãƒªãƒˆãƒ©ã‚¤ â†’ è‡ªå‹•/ç¢ºèª åæ˜ ï¼‰
async function ocrHybridGrid(file, scaleOverride){
  await ensureTesseract();
  const status = (t)=>{ const s=document.getElementById('ocrStatus'); if(s) s.textContent=t||''; };

  // â˜… OCRé–‹å§‹ï¼šãƒœã‚¿ãƒ³ç„¡åŠ¹åŒ–ï¼‹ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä¿å­˜
  setRunButtonEnabled(false);
  PRE_OCR_SNAPSHOT = captureStockSnapshot();

  try{
    status('èª­ã¿å–ã‚Šæº–å‚™â€¦');
    const img = await loadImageAny(file);
    applyGapXClampToUI(img, getGridParamsFromUI());
    applyYOffsetClampToUI(img, getGridParamsFromUI());
    const p = getGridParamsFromUI();

    // ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ
    const grid = [];
    const stepX = p.tileW + p.gapX;
    const stepY = p.tileH + p.gapY;
    const usableW = Math.max(0, img.width - p.left + p.gapX);
    const maxCols = Math.max(1, Math.floor(usableW / stepX));
    const effCols = Math.min(p.cols, maxCols);
    for (let r=0; r<p.rows; r++){
      for (let c=0; c<effCols; c++){
        grid.push({ r, c });
      }
    }

    // ã‚µãƒ ãƒï¼†ã‚¿ã‚¤ãƒ«
    const thumbs = [];
    const tiles  = [];
    const sc = Math.max(0.05, Math.min(1, OCR_CONST.THUMB_W / p.tileW));
    const tc = document.createElement('canvas'); tc.width=Math.round(p.tileW*sc); tc.height=Math.round(p.tileH*sc);
    const tctx = tc.getContext('2d'); tctx.imageSmoothingEnabled=true; tctx.imageSmoothingQuality='high';

    for (const cell of grid){
      const tile = extractTileCanvas(img, p, cell.r, cell.c);
      tiles.push(tile);
      tctx.clearRect(0,0,tc.width,tc.height);
      tctx.drawImage(tile, 0, 0, p.tileW*p.scale, p.tileH*p.scale, 0, 0, tc.width, tc.height);
      thumbs.push(tc.toDataURL('image/png'));
    }

    // å€ç‡ï¼šåˆå›0.75 â†’ æ—¢å®šé…åˆ—
    const scales = (scaleOverride ? [scaleOverride] : [0.75, ...OCR_CONST.RETRY_SCALES]);
    const MAX_PAR = 2; // åŒæ™‚ä¸¦åˆ—æ•°

    status('èª­ã¿å–ã‚Šä¸­â€¦ 0/'+tiles.length);

    // å„ã‚¿ã‚¤ãƒ«ï¼šæ—©æœŸæ‰“ã¡åˆ‡ã‚Šã—ãªãŒã‚‰å‡¦ç†
    const results = new Array(tiles.length);
    let done = 0, nextIdx = 0;

    async function processOne(idx){
      const can = tiles[idx];
      let picked = null;
      for (const s of scales){
        const r = await recognizeTile(can, s);
        r.thumb = thumbs[idx];
        picked = r;
        // è‡ªå‹•æ¡ç”¨æ¡ä»¶ï¼ˆè·é›¢â‰¤1 & æ•°é‡ã‚ã‚Šï¼‰ã‚’æº€ãŸã—ãŸã‚‰æ‰“ã¡åˆ‡ã‚Š
        if (r.best && r.best.id!=null && Number.isFinite(r.qty) && r.qty>0 && r.best.dist <= (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1)) break;
      }
      results[idx] = picked;
      status(`èª­ã¿å–ã‚Šä¸­â€¦ ${++done}/${tiles.length}`);
    }

    async function worker(){
      while(true){
        const i = nextIdx++;
        if (i >= tiles.length) break;
        await processOne(i);
      }
    }
    const workers = Array.from({length: Math.min(MAX_PAR, tiles.length)}, ()=>worker());
    await Promise.all(workers);

    // ä»•åˆ†ã‘
    const auto = [];
    const duplicates = new Map(); // ing -> tiles[]
    const leftovers = [];

    for (let i=0;i<results.length;i++){
      const t = results[i];
      if (!(Number.isFinite(t.qty) && t.qty>0)) { leftovers.push(t); continue; }
      if (!t.best || t.best.id==null) { leftovers.push(t); continue; }
      const ing = DATASET.ingredients[t.best.id]?.name;
      if (!ing) { leftovers.push(t); continue; }
      t.bestName = ing;
      if (isAutoApplyCase(t)) { auto.push(t); continue; }
      if (!duplicates.has(ing)) duplicates.set(ing, []);
      duplicates.get(ing).push(t);
    }

    // è‡ªå‹•ä¸Šæ›¸ãï¼ˆâ€»ãƒˆãƒ¼ã‚¹ãƒˆã¯ã“ã“ã§ã¯å‡ºã•ãªã„ï¼‰
    for (const t of auto){
      const input = findStockInputByName(t.bestName);
      if (!input) continue;
const prev = parseInt(input.value || '0', 10) || 0;
input.value = String(t.qty);
input.dispatchEvent(new Event('input', { bubbles:true }));
// ãƒˆãƒ¼ã‚¹ãƒˆã¯å®Ÿè¡Œå¾Œã«1å›ã ã‘è¡¨ç¤ºï¼ˆã“ã“ã§ã¯å‡ºã•ãªã„ï¼‰
addHistoryLine(`ä¸Šæ›¸ã: ${t.bestName} â† ${t.qty} (auto)`);
    }

    // çµ±åˆï¼šæœªè‡ªå‹•é©ç”¨ã‚¢ã‚¤ãƒ†ãƒ ã®åˆ—æŒ™ãƒªã‚¹ãƒˆ
    const toConfirm = [];
    const included = new Set();

    // é‡è¤‡ï¼ˆè·é›¢æ˜‡é †ã§ä»£è¡¨ã‚’1ä»¶ï¼‰
    for (const [ing, tilesArr] of duplicates.entries()){
      if (tilesArr.length > 1) {
        tilesArr.sort((a,b) => (a.best?.dist ?? 99) - (b.best?.dist ?? 99));
        const pick = tilesArr[0];
        if (pick && !included.has(pick)) { toConfirm.push(pick); included.add(pick); }
      } else if (tilesArr.length === 1) {
        const pick = tilesArr[0];
        if (pick && !included.has(pick)) { toConfirm.push(pick); included.add(pick); }
      }
    }

    // æ•°é‡ã—ãã„å€¤ä»¥ä¸Šï¼ˆå˜ç™ºã§ã‚‚ï¼‰
    results.forEach(t => {
      if (included.has(t)) return;
      if (t.best && Number.isFinite(t.qty) && t.qty >= (OCR_CONST.AUTO_CONFIRM_QTY_MIN ?? 300)) {
        toConfirm.push(t); included.add(t);
      }
    });

    // ã‚ã„ã¾ã„ï¼æ•°é‡æœªå–å¾—
    results.forEach(t => {
      if (included.has(t)) return;
      const needConfirm =
        !t.best ||
        (t.best && t.best.dist > (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1)) ||
        !(Number.isFinite(t.qty) && t.qty > 0);
      if (needConfirm) { toConfirm.push(t); included.add(t); }
    });

    // ç¢ºèªUI
    if (toConfirm.length){
      toConfirm.forEach(t => { t.bestDist = t.best?.dist ?? null; });
      renderConfirmPanelUnified(toConfirm);
    } else {
      document.getElementById('confirmPanel')?.classList.add('d-none');
    }

    // ã‚µãƒ ãƒã‚¤ãƒ«è¡¨ç¤ºï¼ˆã‚«ãƒ¼ãƒ‰å†…æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
    document.getElementById('gridPreview')?.classList.remove('d-none');
    await buildTileThumbnails(file);

    status(results.length ? 'èª­ã¿å–ã‚Šå®Œäº†' : 'æ¤œå‡ºãªã—');

    // â˜… OCRå®Œäº†ï¼šã“ã“ã§1å›ã ã‘ãƒˆãƒ¼ã‚¹ãƒˆè¡¨ç¤ºï¼ˆ3ç§’é–“ã¯èª­å–ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹ã®ã¾ã¾ï¼‰
    showUndoToastAfterRun();

    return results.length;
  } catch (err){
    console.error(err); status('ã‚¨ãƒ©ãƒ¼');
    // å¤±æ•—æ™‚ã¯ãƒˆãƒ¼ã‚¹ãƒˆå‡ºã•ãšã€ãƒœã‚¿ãƒ³å†æœ‰åŠ¹åŒ–ï¼†ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆç ´æ£„
    PRE_OCR_SNAPSHOT = null;
    setRunButtonEnabled(true);
    return 0;
  }
}

function isAutoApplyCase(t){
  if (!t || !t.best || t.best.id==null) return false;
  if (!(Number.isFinite(t.qty) && t.qty>0)) return false; // æ•°é‡å¿…é ˆ
  // æ•°é‡ãŒå¤§ãã™ãã‚‹å ´åˆã¯ç¢ºèªã¸å›ã™
  if (t.qty >= OCR_CONST.AUTO_CONFIRM_QTY_MIN) return false;
  // è·é›¢ãŒååˆ†å°ã•ã„ï¼ˆâ‰¦1ï¼‰ã®ã¿è‡ªå‹•ä¸Šæ›¸ã
  return (t.best.dist <= (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1));
}


    // ã‚«ãƒ¡ãƒ©UIï¼ˆé–‹é–‰ãƒ»è¡Œæ•°ãƒ»ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ»èª­å–ï¼‰
    function bindCameraUI() {
      const toggleBtn = document.getElementById('cameraToggle');
      const refreshBtn = document.getElementById('cameraRefresh');
      const area = document.getElementById('cameraArea');
      const file = document.getElementById('cameraFile');
      const fileBtn = document.getElementById('fileSelectBtn');
      const fileName = document.getElementById('fileName');
      const s1 = document.getElementById('cameraSlider1');
      const s2 = document.getElementById('cameraSlider2');
      const readBtn = document.getElementById('cameraReadBtn');
      const rowCount = document.getElementById('rowCount');
      const gridPreview = document.getElementById('gridPreview');
      const debugToggle = document.getElementById('debugToggle');

      OCR.status = document.getElementById('ocrStatus');

      const setOpen = (open) => {
        toggleBtn.setAttribute('aria-pressed', open ? 'true' : 'false');
        toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
        area.classList.toggle('d-none', !open);
        area.setAttribute('aria-hidden', open ? 'false' : 'true');
        refreshBtn.classList.toggle('d-none', !open);
        if (!open) gridPreview.classList.add('d-none');
        toggleBtn.classList.toggle('btn-primary', open);
        toggleBtn.classList.toggle('btn-outline-secondary', !open);
      };
      setOpen(false);

      toggleBtn.addEventListener('click', () => {
        const open = toggleBtn.getAttribute('aria-pressed') !== 'true';
        setOpen(open);
      });

      fileBtn.addEventListener('click', () => file.click());
      file.addEventListener('change', async () => {
        const has = file.files && file.files.length;
        const name = has ? file.files[0].name : 'æœªé¸æŠ';
        fileName.textContent = name;
        gridPreview.classList.toggle('d-none', !has);
        if (!has) { gridPreview.classList.add('d-none'); document.getElementById('tileThumbs').innerHTML=''; return; }
        __lastFile = file.files[0];
        await buildTileThumbnails(__lastFile);
      });

      function updateRowButtons() {
        [...rowCount.querySelectorAll('button[data-rows]')].forEach(btn => {
          const isActive = parseInt(btn.dataset.rows, 10) === gridRowCount;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }
      rowCount.addEventListener('click', async (e) => {
        const btn = e.target.closest('button[data-rows]');
        if (!btn) return;
        gridRowCount = parseInt(btn.dataset.rows, 10) || 4;
        updateRowButtons();
        if (__lastFile) await buildTileThumbnails(__lastFile);
      });
      updateRowButtons();

      s1.addEventListener('input', async () => { if (__lastFile) await buildTileThumbnails(__lastFile); });
      s2.addEventListener('input', async () => { if (__lastFile) await buildTileThumbnails(__lastFile); });

      refreshBtn.addEventListener('click', async () => {
        gridRowCount = 4; updateRowButtons();
        s1.value = '50'; s2.value = '50'; delete s1.dataset.gapx; delete s2.dataset.yofs;
        file.value = ''; fileName.textContent = 'æœªé¸æŠ';
        document.getElementById('tileThumbs').innerHTML='';
        gridPreview.classList.add('d-none');
        document.getElementById('confirmPanel').classList.add('d-none');
        document.getElementById('leftoverPanel').classList.add('d-none');
        if (OCR.status) OCR.status.textContent = '';
      });

      debugToggle.addEventListener('change', ()=>{ OCR.debug = !!debugToggle.checked; if (!OCR.debug) setDebugLines(''); else setDebugLines('(ON)'); });

      readBtn.addEventListener('click', async () => {
        try{
          readBtn.disabled = true;
          if (!__lastFile) { alert('ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }
          await ocrHybridGrid(__lastFile);
        }catch(e){ console.error(e); alert('èª­å–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'); }
        finally{ readBtn.disabled = false; }
      });
    }

    // =========================
    // èµ·å‹•
    // =========================
    (async function init(){
      DATASET = await loadDataset();
      buildIndexes(DATASET);
      buildIngredientMatchers();
      bindGroup1();
      bindClearAll();
      bindCameraUI();
      renderAll();
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
