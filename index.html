<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>ポケスリ食材計算ツール（OCR統合・上書き反映）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* レイアウト調整（モバイル→縦、lg以上→左右） */
    .sticky-col { position: sticky; top: 1rem; }
    .qty-input { text-align: center; }
    .w-9ch { width: 9ch; }
    .w-6ch { width: 6ch; } /* G3 所持入力を狭く */
    .table-sm td, .table-sm th { vertical-align: middle; }
    #totalTable th { white-space: nowrap; } /* ヘッダー折返し防止 */
    .empty-hint { color: #6c757d; }

    /* 数値入力のスピントグル非表示（全体） */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }

    /* ステッパー幅：統一（グループ1/2共通） */
    .stepper-compact { width: 130px; max-width: 130px; }

    /* ステッパーボタン幅固定（端末差を吸収） */
    .btn-step { width: 36px; padding-left: 0; padding-right: 0; display: inline-flex; justify-content: center; align-items: center; }

    /* --- 食材画像UI --- */
    .ing-img { display: inline-block; object-fit: contain; border-radius: .35rem; background-color: #f8f9fa; }
    .ing-32 { width: 32px; height: 32px; }
    .ing-28 { width: 28px; height: 28px; }

    .ing-chip { display: inline-flex; align-items: center; gap: .35rem; padding: .15rem .2rem; flex: 0 0 auto; }
    .ing-count { font-variant-numeric: tabular-nums; }

    .ing-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: .35rem .75rem; }
    .ing-grid-item { display: inline-flex; align-items: center; gap: .35rem; min-width: 0; }

    .ing-label-minitext { font-size: 10px; color: #6c757d; white-space: nowrap; }

    /* G3：2〜4列（必要・所持・不足）中央寄せ */
    #totalTable th:nth-child(2),
    #totalTable th:nth-child(3),
    #totalTable th:nth-child(4),
    #totalTable td:nth-child(2),
    #totalTable td:nth-child(3),
    #totalTable td:nth-child(4) { text-align: center; }
    #totalTable td:nth-child(3) .form-control { margin-left: auto; margin-right: auto; text-align: center; }

    /* カメラUI */
    .camera-stack { display: grid; gap: .5rem; }

    /* G1プレビュー：常に横一行（横スクロール） */
    #g1Preview { display: flex; gap: .5rem; flex-wrap: nowrap; overflow-x: auto; -webkit-overflow-scrolling: touch; white-space: nowrap; }

    /* OCRプレビュー領域（初期は非表示） */
    #gridPreview { display: flex; flex-direction: column; gap: .5rem; border: 1px dashed #dee2e6; border-radius: .5rem; background: #f8f9fa; padding: .5rem; }
    #tileThumbs { display: flex; gap: 6px; overflow-x: auto; white-space: nowrap; min-height: 64px; }
    #gridPreview, #gridPreview * { cursor: default; }

    /* バッジ（やわらか色） */
    .badge-soft { color: #0c5460; background: #e2f3f5; border: 1px solid #bde1e6; }

    /* 確認パネル */
    #confirmPanel .card-title small { color: #6c757d; }
    .tile-thumb { width: 40px; height: auto; border: 1px solid #eee; border-radius: 4px; }

    /* トースト通知 */
    .toast-container { position: fixed; inset: auto 1rem 1rem auto; z-index: 1080; }

    /* デバッグ領域（既定OFF） */
    #ocrDebug { display: none; }

/* --- Preview in-card behavior --- */
#gridPreview {
  max-width: 100%;
  overflow: hidden;          /* カード外にはみ出さない */
  padding: .5rem;
}
#tileThumbs {
  display: flex;
  gap: 6px;
  flex-wrap: nowrap;         /* 横一列固定 */
  overflow-x: auto;          /* 横スクロール */
  overflow-y: hidden;        /* 縦スクロールは禁止 */
  -webkit-overflow-scrolling: touch;
  max-width: 100%;
}
.tile-thumb {
  flex: 0 0 auto;            /* 固定幅で並べる */
  width: 40px;
  height: auto;
}

/* 最有力ラインは非表示（要望により） */
#bestLine { display: none !important; }

  </style>
  <link rel="icon" href="data:,">
</head>
<body>
  <header class="container py-3">
    <h1 class="h4 m-0">ポケスリ食材計算ツール</h1>
    <p class="text-muted small mb-0">dataset.json 読み込み／A/B/Cグループ・slug順対応／食材画像UI／OCRで所持上書き</p>
  </header>

  <main class="container">
    <div class="row g-3">
      <!-- 左カラム：グループ1＆2 -->
      <div class="col-12 col-lg-6">
        <div class="sticky-col">
          <!-- ANCHOR:G1 -->
          <div class="card mb-3">
            <div class="card-body">
              <div class="mb-2">
                <div class="btn-group" role="group" aria-label="weekly group">
                  <input type="radio" class="btn-check" name="weeklyGroup" id="wgA" autocomplete="off" value="A" checked>
                  <label class="btn btn-outline-primary" for="wgA" id="wgLabelA">カレー</label>
                  <input type="radio" class="btn-check" name="weeklyGroup" id="wgB" autocomplete="off" value="B">
                  <label class="btn btn-outline-primary" for="wgB" id="wgLabelB">サラダ</label>
                  <input type="radio" class="btn-check" name="weeklyGroup" id="wgC" autocomplete="off" value="C">
                  <label class="btn btn-outline-primary" for="wgC" id="wgLabelC">デザート</label>
                </div>
              </div>

              <div class="mb-2">
                <select id="recipeSelect" class="form-select" aria-label="料理を選択"></select>
              </div>

              <!-- G1プレビュー（横一行固定、横スクロール） -->
              <div id="g1Preview" class="g1-preview small mb-2" aria-live="polite" aria-atomic="true"></div>

              <div class="input-group input-group-sm stepper-compact">
                <button id="qtyMinus" class="btn btn-outline-secondary btn-step" type="button">－</button>
                <input id="qtyInput" class="form-control qty-input" type="number" inputmode="numeric" pattern="[0-9]*" value="1" min="1" step="1">
                <button id="qtyPlus" class="btn btn-outline-secondary btn-step" type="button">＋</button>
              </div>

              <div class="mt-2">
                <button id="addBtn" class="btn btn-primary btn-sm" type="button">追加</button>
              </div>
            </div>
          </div>

          <!-- ANCHOR:G2 -->
          <div id="group2Card" class="card d-none">
            <div class="card-header d-flex align-items-center justify-content-between">
              <span class="fw-semibold">追加済みレシピ</span>
              <button id="clearAllBtn" class="btn btn-sm btn-outline-danger" type="button" aria-label="追加済みレシピを全削除">全削除</button>
            </div>
            <div class="card-body" id="group2Body">
              <p class="empty-hint m-0">まだ料理がありません。「追加」で投入してください。</p>
            </div>
          </div>
        </div>
      </div>

      <!-- 右カラム：グループ3（常時表示） -->
      <div class="col-12 col-lg-6">
        <!-- ANCHOR:G3 -->
        <div id="group3Card" class="card">
          <div class="card-header d-flex align-items-center justify-content-between">
            <span class="fw-semibold">食材合計</span>
            <button id="resetStockBtn" class="btn btn-sm btn-outline-secondary" type="button" aria-label="在庫をクリア">在庫クリア</button>
          </div>
          <div class="card-body">
            <!-- ▼ カメラUI -->
            <div id="cameraPanel" class="mb-3">
              <div class="d-flex align-items-center camera-row gap-2 mb-2">
                <button id="cameraToggle" class="btn btn-outline-secondary btn-sm" type="button"
                        aria-pressed="false" aria-expanded="false" aria-controls="cameraArea" aria-label="カメラを開閉">📷</button>
                <button id="cameraRefresh" class="btn btn-outline-secondary btn-sm ms-2 d-none" type="button" aria-label="リセット">↻</button>
                <div class="form-check form-switch ms-auto">
                  <input class="form-check-input" type="checkbox" id="debugToggle">
                  <label class="form-check-label small" for="debugToggle">デバッグ</label>
                </div>
              </div>
              <div id="cameraArea" class="camera-stack d-none" aria-hidden="true">
                <div>
                  <input id="cameraFile" type="file" accept="image/*" class="d-none" />
                  <button id="fileSelectBtn" class="btn btn-outline-primary btn-sm" type="button" aria-label="ファイルを選択">ファイルを選択</button>
                  <span id="fileName" class="ms-2 text-muted small">未選択</span>
                </div>
                <!-- 行数選択（1|2|3|4） -->
                <div>
                  <div id="rowCount" class="btn-group" role="group" aria-label="行数選択">
                    <button type="button" class="btn btn-outline-secondary btn-sm" data-rows="1" aria-pressed="false" title="グリッドの行数を1に設定">1</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" data-rows="2" aria-pressed="false" title="グリッドの行数を2に設定">2</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" data-rows="3" aria-pressed="false" title="グリッドの行数を3に設定">3</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm active" data-rows="4" aria-pressed="true" title="グリッドの行数を4に設定">4</button>
                  </div>
                </div>
                <!-- gapX, yOffset スライダー（将来的に tileH も追加余地） -->
<!-- gapX → yOffset の順に縦配置 -->
<div class="mb-2">
  <label for="cameraSlider1" class="form-label mb-1 small">列間隔 gapX</label>
  <input id="cameraSlider1" type="range" min="0" max="100" value="50" class="form-range" aria-label="gapX">
</div>
<div class="mb-2">
  <label for="cameraSlider2" class="form-label mb-1 small">下端基準 yOffset</label>
  <input id="cameraSlider2" type="range" min="0" max="100" value="50" class="form-range" aria-label="yOffset">
</div>

                <div class="d-flex gap-2">
                  <button id="cameraReadBtn" class="btn btn-primary btn-sm" type="button">読取</button>
                  <div id="ocrStatus" class="small text-muted align-self-center"></div>
                </div>
                <!-- サムネイル／結果の最有力候補ライン（生文字列） -->
                <div id="gridPreview" class="mb-2 d-none" aria-label="グリッドOCRプレビュー">
                  <div id="tileThumbs"></div>
                  <div id="bestLine" class="small text-muted"></div>
                </div>
                <!-- 確認パネル（あいまい／重複時のみ表示） -->
                <div id="confirmPanel" class="d-none"></div>
                <!-- 残タイルの処理（破棄/手動割当） -->
                <div id="leftoverPanel" class="d-none"></div>
                <!-- デバッグ出力（トグルON時のみ） -->
                <div id="ocrDebug" class="mt-2">
                  <div class="small" style="color:#666">デバッグ出力（倍率・生文字列・候補など）</div>
                  <pre id="debugPre" class="p-2 border bg-light" style="max-height:260px; overflow:auto; font-size:12px;"></pre>
                </div>
              </div>
            </div>
            <!-- ▲ カメラUI -->

            <!-- 合計テーブル -->
            <div class="table-responsive">
              <table id="totalTable" class="table table-sm align-middle">
                <thead>
                  <tr>
                    <th scope="col">食材</th>
                    <th scope="col">必要</th>
                    <th scope="col">所持</th>
                    <th scope="col">不足</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
              <p id="totalEmpty" class="empty-hint">まだレシピがありません。</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- トースト（下右） -->
  <div class="toast-container">
    <div id="applyToast" class="toast" role="status" aria-live="polite" aria-atomic="true">
      <div class="toast-header">
        <strong class="me-auto">所持を上書きしました</strong>
        <small class="text-muted">OCR</small>
        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
      <div class="toast-body"></div>
    </div>
  </div>

  <script>
    // =========================
    // 外部データ読み込み（失敗時はフォールバック）
    // =========================
    const DEFAULT_DATA = {
      weeklyGroups: [
        { id: 'A', label: 'カレー' },
        { id: 'B', label: 'サラダ' },
        { id: 'C', label: 'デザート' }
      ],
      recipes: [
        { id: 'とくせんリンゴカレー', name: 'とくせんリンゴカレー', group: 'A', slug: 'a-fallback-01', per: { 'とくせんリンゴ': 7 } }
      ],
      ingredients: [
        { name: 'とくせんリンゴ', img: 'images/ingredients/apple.png', aliases: [] }
      ]
    };

    let DATASET = null;
    const DATASET_INDEX = { bySlug: Object.create(null), byId: Object.create(null) };

    // 食材インデックス（name/aliases → レコード）& 順序
    let ING_INDEX = Object.create(null);
    let ING_ORDER = Object.create(null); // name -> index（ingredients配列の順番）

    // =========================
    // localStorage（v1）
    // =========================
    const LS = { CART: 'ps-v1-cart', STOCK: 'ps-v1-stock' };

    function saveCartToLS() {
      try {
        const items = [...cart.entries()].map(([slug, { qty }]) => [slug, qty]);
        localStorage.setItem(LS.CART, JSON.stringify({ items }));
      } catch (e) { console.warn('saveCartToLS failed', e); }
    }

    function loadCartFromLS() {
      try {
        const raw = JSON.parse(localStorage.getItem(LS.CART) || '{}');
        const items = raw.items || [];
        const m = new Map();
        for (const [slug, qty] of items) {
          m.set(slug, { qty: Math.max(1, parseInt(qty || '1', 10) || 1) });
        }
        return m;
      } catch (e) { return new Map(); }
    }

    function saveStockToLS() {
      try {
        const entries = [...stock.entries()];
        localStorage.setItem(LS.STOCK, JSON.stringify({ entries }));
      } catch (e) { console.warn('saveStockToLS failed', e); }
    }

    function loadStockFromLS() {
      try {
        const raw = JSON.parse(localStorage.getItem(LS.STOCK) || '{}');
        const entries = raw.entries || [];
        return new Map(entries);
      } catch (e) { return new Map(); }
    }

    // =========================
    // 状態
    // =========================
    const cart  = loadCartFromLS(); // Map<slug,{qty}>
    const stock = loadStockFromLS(); // Map<name,have>

    // =========================
    // dataset.json 読み込み
    // =========================
    async function loadDataset() {
      try {
        const res = await fetch('dataset.json', { cache: 'no-cache' });
        if (!res.ok) throw new Error('dataset fetch failed');
        const data = await res.json();
        return data;
      } catch (e) {
        console.warn('dataset.json load failed. use DEFAULT_DATA', e);
        return DEFAULT_DATA;
      }
    }

    function buildIndexes(data) {
      DATASET_INDEX.bySlug = Object.create(null);
      DATASET_INDEX.byId   = Object.create(null);
      data.recipes.forEach(r => {
        const slug = r.slug || r.id;
        DATASET_INDEX.bySlug[slug] = r;
        DATASET_INDEX.byId[r.id] = r;
      });

      ING_INDEX = Object.create(null);
      ING_ORDER = Object.create(null);
      data.ingredients.forEach((ing, idx) => {
        const names = [ing.name, ...(ing.aliases || [])].filter(Boolean);
        for (const k of names) ING_INDEX[k] = ing; // name/alias → レコード
        ING_ORDER[ing.name] = idx;
      });
    }

    function getRecipeListByGroup(group) {
      const list = DATASET.recipes.filter(r => (r.group || 'A') === group);
      list.sort((a,b) => (a.slug||a.id).localeCompare(b.slug||b.id, 'ja'));
      return list;
    }

    function getRecipeParts(recipe) {
      const per = recipe.per || {};
      return Object.entries(per);
    }

function createIngImg(name, cls='ing-32') {
  const img = document.createElement('img');
  const rec = ING_INDEX[name];
  img.alt = name;
  img.title = name;
  img.className = `ing-img ${cls}`;

  // 文字ベースのSVGプレースホルダ（404時に即座に切替）
  const svg = encodeURIComponent(
    `<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'>
      <rect width='100%' height='100%' fill='#f1f3f5'/>
      <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle'
            font-size='10' fill='#6c757d'>${(name||'').slice(0,2)}</text>
    </svg>`
  );
  const fallback = `data:image/svg+xml;charset=utf-8,${svg}`;

  img.src = (rec && rec.img) ? rec.img : fallback;
  img.onerror = () => { img.onerror = null; img.src = fallback; };

  return img;
}


    // =========================
    // G1（選択 → 追加）
    // =========================
    let weeklyGroup = 'A';

    function bindGroup1() {
      const radA = document.getElementById('wgA');
      const radB = document.getElementById('wgB');
      const radC = document.getElementById('wgC');
      const select = document.getElementById('recipeSelect');
      const g1Prev = document.getElementById('g1Preview');
      const qtyMinus = document.getElementById('qtyMinus');
      const qtyPlus  = document.getElementById('qtyPlus');
      const qtyInput = document.getElementById('qtyInput');
      const addBtn   = document.getElementById('addBtn');

      const renderGroupLabel = () => {
        const A = DATASET.weeklyGroups.find(g=>g.id==='A');
        const B = DATASET.weeklyGroups.find(g=>g.id==='B');
        const C = DATASET.weeklyGroups.find(g=>g.id==='C');
        if (A) document.getElementById('wgLabelA').textContent = A.label || 'A';
        if (B) document.getElementById('wgLabelB').textContent = B.label || 'B';
        if (C) document.getElementById('wgLabelC').textContent = C.label || 'C';
      };

      const renderSelect = () => {
        select.innerHTML = '';
        const list = getRecipeListByGroup(weeklyGroup);
        const empty = document.createElement('option'); empty.value = ''; empty.textContent = '— 料理を選択 —'; select.appendChild(empty);
        for (const r of list) {
          const opt = document.createElement('option');
          opt.value = r.slug || r.id;
          opt.textContent = r.name || r.id;
          select.appendChild(opt);
        }
      };

      const renderPreview = (slug, qty) => {
        g1Prev.innerHTML = '';
        if (!slug) return;
        const r = DATASET_INDEX.bySlug[slug];
        const per = r?.per || {};
        for (const [ing, base] of Object.entries(per)) {
          const chip = document.createElement('span'); chip.className = 'ing-chip border rounded bg-light';
          chip.appendChild(createIngImg(ing, 'ing-28'));
          const txt = document.createElement('span'); txt.textContent = `× ${base * qty}`; txt.className = 'ing-count';
          chip.appendChild(txt);
          g1Prev.appendChild(chip);
        }
      };

      const setQty = (v) => { const n = Math.max(1, parseInt(v||'1',10)||1); qtyInput.value = String(n); return n; };

      radA.addEventListener('change', () => { if (radA.checked) { weeklyGroup = 'A'; renderSelect(); renderPreview(select.value, setQty(qtyInput.value)); } });
      radB.addEventListener('change', () => { if (radB.checked) { weeklyGroup = 'B'; renderSelect(); renderPreview(select.value, setQty(qtyInput.value)); } });
      radC.addEventListener('change', () => { if (radC.checked) { weeklyGroup = 'C'; renderSelect(); renderPreview(select.value, setQty(qtyInput.value)); } });
      select.addEventListener('change', () => renderPreview(select.value, setQty(qtyInput.value)));
      qtyMinus.addEventListener('click', () => renderPreview(select.value, setQty((parseInt(qtyInput.value||'1',10)||1)-1)));
      qtyPlus .addEventListener('click', () => renderPreview(select.value, setQty((parseInt(qtyInput.value||'1',10)||1)+1)));
      qtyInput.addEventListener('input', () => renderPreview(select.value, setQty(qtyInput.value)));

      addBtn.addEventListener('click', () => {
        const slug = select.value; if (!slug) return;
        const q = Math.max(1, parseInt(qtyInput.value||'1',10)||1);
        cart.set(slug, { qty: q });
        renderAll();
        saveCartToLS();
      });

      renderGroupLabel(); renderSelect(); renderPreview('', setQty(qtyInput.value));
    }

    // =========================
    // G2（レシピカード）
    // =========================
    function createCardStepper(initialQty, onLiveChange, onCommit) {
      const group = document.createElement('div');
      group.className = 'input-group input-group-sm stepper-compact';

      const minus = document.createElement('button');
      minus.className = 'btn btn-outline-secondary btn-step';
      minus.type = 'button';
      minus.textContent = '－';

      const input = document.createElement('input');
      input.className = 'form-control qty-input';
      input.type = 'number'; input.inputMode = 'numeric'; input.pattern = '[0-9]*'; input.min = '1'; input.step = '1'; input.value = String(initialQty);

      const plus = document.createElement('button');
      plus.className = 'btn btn-outline-secondary btn-step';
      plus.type = 'button';
      plus.textContent = '＋';

      const clamp = (v) => { const n = parseInt(v || '1', 10); return isNaN(n) ? 1 : Math.max(1, n); };

      const sync = () => { const q = clamp(input.value); input.value = String(q); onLiveChange?.(q); };
      const commit = () => { const q = clamp(input.value); onCommit?.(q); };

      minus.addEventListener('click', () => { input.value = String(Math.max(1, (parseInt(input.value||'1',10)||1) - 1)); sync(); commit(); });
      plus .addEventListener('click', () => { input.value = String((parseInt(input.value||'1',10)||1) + 1); sync(); commit(); });
      input.addEventListener('input', sync);
      input.addEventListener('change', commit);

      group.appendChild(minus); group.appendChild(input); group.appendChild(plus);
      return group;
    }

    function renderRecipeCard(slug, recipeName, qty, recipe) {
      const card = document.createElement('div');
      card.className = 'card';

      const header = document.createElement('div');
      header.className = 'card-header d-flex justify-content-between align-items-center gap-2';

      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = recipeName;

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-sm btn-outline-danger';
      delBtn.textContent = '×';
      delBtn.addEventListener('click', () => { cart.delete(slug); renderAll(); saveCartToLS(); });

      header.appendChild(title); header.appendChild(delBtn);
      card.appendChild(header);

      const body = document.createElement('div');
      body.className = 'card-body';

      const list = document.createElement('div');
      list.className = 'ing-grid';

      const updateListForQty = (q) => {
        list.innerHTML = '';
        for (const [ing, base] of getRecipeParts(recipe)) {
          const item = document.createElement('div');
          item.className = 'ing-grid-item';
          item.appendChild(createIngImg(ing, 'ing-32'));
          const cnt = document.createElement('span'); cnt.className = 'ing-count'; cnt.textContent = `× ${base * q}`;
          item.appendChild(cnt);
          list.appendChild(item);
        }
      };

      const stepper = createCardStepper(
        qty,
        (liveQty)  => { updateListForQty(liveQty); },
        (commitQty)=> { cart.set(slug, { qty: Math.max(1, commitQty) }); renderTotals(); saveCartToLS(); }
      );

      updateListForQty(qty);

      const ctlRow = document.createElement('div');
      ctlRow.className = 'd-flex flex-wrap align-items-center gap-2 mb-2';
      ctlRow.appendChild(stepper);

      body.appendChild(ctlRow);
      body.appendChild(list);
      card.appendChild(body);

      return card;
    }

    function renderGroup2() {
      const body = document.getElementById('group2Body');
      body.innerHTML = '';

      if (cart.size === 0) {
        const p = document.createElement('p');
        p.className = 'empty-hint m-0';
        p.textContent = 'まだ料理がありません。「追加」で投入してください。';
        body.appendChild(p);
        return;
      }

      const grid = document.createElement('div');
      grid.className = 'row g-3';

      for (const [slug, { qty }] of cart) {
        const r = DATASET_INDEX.bySlug[slug];
        const col = document.createElement('div');
        col.className = 'col-12';
        col.appendChild(renderRecipeCard(slug, r.name, qty, r));
        grid.appendChild(col);
      }
      body.appendChild(grid);
    }

    function bindClearAll() {
      const clearBtn = document.getElementById('clearAllBtn');
      if (!clearBtn) return;
      clearBtn.addEventListener('click', () => {
        if (cart.size === 0) return;
        if (!confirm('本当に全削除しますか？')) return;
        cart.clear();
        renderAll();
        saveCartToLS();
      });
    }

    // =========================
    // G3（集計テーブル／所持入力）
    // =========================
    function renderTotals() {
      const tbody = document.querySelector('#totalTable tbody');
      const empty = document.getElementById('totalEmpty');
      const resetBtn = document.getElementById('resetStockBtn');
      tbody.innerHTML = '';

      if (cart.size === 0) {
        empty.style.display = '';
        if (resetBtn) resetBtn.disabled = true;
        return;
      }
      empty.style.display = 'none';
      if (resetBtn) resetBtn.disabled = false;

      // 集計：ingredient -> needTotal（遭遇順も保持）
      const needMap = new Map();
      const encounterOrder = new Map();
      let seq = 0;
      for (const [slug, { qty }] of cart) {
        const per = DATASET_INDEX.bySlug[slug].per || {};
        for (const [ing, base] of Object.entries(per)) {
          if (!encounterOrder.has(ing)) encounterOrder.set(ing, seq++);
          needMap.set(ing, (needMap.get(ing) || 0) + base * qty);
        }
      }

      for (const ing of needMap.keys()) if (!stock.has(ing)) stock.set(ing, 0);

      const rowsKnown = [];
      const rowsUnknown = [];
      for (const [ing, need] of needMap.entries()) {
        const idx = ING_ORDER[ing];
        if (typeof idx === 'number') rowsKnown.push({ ing, need, idx });
        else rowsUnknown.push({ ing, need, ord: encounterOrder.get(ing) });
      }
      rowsKnown.sort((a,b) => a.idx - b.idx);
      rowsUnknown.sort((a,b) => a.ord - b.ord);
      const rows = rowsKnown.concat(rowsUnknown);

      for (const row of rows) {
        const { ing, need } = row;
        const tr = document.createElement('tr');
        tr.dataset.ing = ing;

        const tdIng = document.createElement('td');
        const ingWrap = document.createElement('div'); ingWrap.className = 'd-flex align-items-center gap-2';
        ingWrap.appendChild(createIngImg(ing, 'ing-28'));
        const label = document.createElement('span'); label.className = 'ing-label-minitext'; label.textContent = ing; // G3のみ極小ラベル
        ingWrap.appendChild(label);
        tdIng.appendChild(ingWrap);

        const tdNeed = document.createElement('td'); tdNeed.textContent = String(need);

        const tdHave = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'number'; input.className = 'form-control form-control-sm w-6ch';
        input.min = '0'; input.step = '1'; input.inputMode = 'numeric'; input.pattern = '[0-9]*';
        input.value = String(stock.get(ing) || 0);
        tdHave.appendChild(input);

        const tdLack = document.createElement('td');
        tdLack.textContent = String(Math.max(need - (stock.get(ing) || 0), 0));

        input.addEventListener('input', () => {
          let v = parseInt(input.value || '0', 10);
          if (isNaN(v) || v < 0) v = 0;
          input.value = String(v);
          stock.set(ing, v);
          tdLack.textContent = String(Math.max(need - v, 0));
          saveStockToLS();
        });

        tr.appendChild(tdIng); tr.appendChild(tdNeed); tr.appendChild(tdHave); tr.appendChild(tdLack);
        tbody.appendChild(tr);
      }
    }

    // 在庫クリア
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('#resetStockBtn');
      if (!btn) return;
      if (!confirm('在庫を0にリセットします。よろしいですか？')) return;
      stock.clear();
      renderTotals();
      saveStockToLS();
    });

    // レイアウト描画
    function renderAll() {
      renderGroup2();
      renderTotals();

      const g2 = document.getElementById('group2Card');
      const clearBtn = document.getElementById('clearAllBtn');
      if (cart.size === 0) {
        g2.classList.add('d-none');
        if (clearBtn) clearBtn.disabled = true;
      } else {
        g2.classList.remove('d-none');
        if (clearBtn) clearBtn.disabled = false;
      }
    }

    // =========================
    // OCR（カメラUI統合・上書き反映）
    // =========================
    const OCR = {
      status: null, out: null, debug: false,
      W_NAME: null, W_DIG: null, langReady: false, loading: false,
    };

const OCR_CONST = {
  MAX_DIST: 3,                         // 名前マッチ距離の上限
  AUTO_APPLY_DIST_MAX: 1,              // 自動上書きに許容する最大距離
  AUTO_CONFIRM_QTY_MIN: 300,           // ★この数量以上は確認へ（自動上書きしない）
  RETRY_SCALES: [0.75, 1.0, 1.25, 1.5], // +0,+33,+50,-25,-33,-50%
  COLS: 4,                             // 列は固定
  ROWS_MIN: 1, ROWS_MAX: 4, ROWS_DEF: 4,
  THUMB_W: 40
};

// === OCR実行前スナップショット & ボタン制御（UNDO用） ===
let PRE_OCR_SNAPSHOT = null;       // [{ ing, val }, ...] を保持

function getOcrRunButton(){
  // 既存IDやdata属性に広めに対応
  return document.querySelector(
    '#btnOcrRun, [data-action="ocr-run"], button[data-ocr-run], #btnCameraRun, button#runOcr'
  );
}

function setRunButtonEnabled(enabled){
  const btn = getOcrRunButton();
  if (!btn) return;
  btn.disabled = !enabled;
  btn.classList.toggle('disabled', !enabled);
}

function captureStockSnapshot(){
  const snap = [];
  (DATASET.ingredients || []).forEach(rec => {
    const input = findStockInputByName(rec.name);
    if (input) {
      const val = parseInt(input.value || '0', 10) || 0;
      snap.push({ ing: rec.name, val });
    }
  });
  return snap;
}

function applyStockSnapshot(snap){
  if (!Array.isArray(snap)) return 0;
  let cnt = 0;
  for (const it of snap){
    const input = findStockInputByName(it.ing);
    if (!input) continue;
    input.value = String(it.val);
    input.dispatchEvent(new Event('input', { bubbles: true }));
    cnt++;
  }
  return cnt;
}

// === 実行後トースト（3秒表示・元に戻す=S1 強制復元） ===
let OCR_TOAST_TIMER = null;

function showUndoToastAfterRun(){
  // トースト置場
  let area = document.getElementById('toastArea');
  if (!area) {
    area = document.createElement('div');
    area.id = 'toastArea';
    area.className = 'position-fixed bottom-0 end-0 p-3';
    area.style.zIndex = '1080';
    document.body.appendChild(area);
  }
  // 既存トーストがあれば消す（常に1つ）
  area.innerHTML = '';

  const toast = document.createElement('div');
  toast.className = 'toast show border-0 shadow-sm';
  toast.setAttribute('role','status');
  toast.setAttribute('aria-live','polite');
  toast.setAttribute('aria-atomic','true');
  toast.innerHTML = `
    <div class="toast-body d-flex align-items-center gap-3">
      <span>上書きしました</span>
      <button type="button" class="btn btn-sm btn-outline-secondary ms-auto" id="undoAll">元に戻す</button>
    </div>`;
  area.appendChild(toast);

  const finish = () => {
    if (OCR_TOAST_TIMER) { clearTimeout(OCR_TOAST_TIMER); OCR_TOAST_TIMER = null; }
    toast.classList.remove('show'); toast.classList.add('hide');
    setTimeout(()=>{ toast.remove(); }, 200);
    // 3秒経過 or Undo後はボタンを再有効化
    setRunButtonEnabled(true);
  };

  // Undo：OCR実行前の状態に強制復元（S1）
  toast.querySelector('#undoAll').addEventListener('click', () => {
    try {
      const n = applyStockSnapshot(PRE_OCR_SNAPSHOT);
      addHistoryLine(`元に戻す: 読取前の状態へ復元（${n}項目）`);
      // 確認パネルが開いていれば閉じる
      const panel = document.getElementById('confirmPanel');
      if (panel){ panel.innerHTML=''; panel.classList.add('d-none'); }
    } catch(e){ console.warn(e); }
    finally {
      PRE_OCR_SNAPSHOT = null;
      finish();
    }
  });

  // 3秒で自動クローズ
  OCR_TOAST_TIMER = setTimeout(() => {
    PRE_OCR_SNAPSHOT = null;
    finish();
  }, 3000);
}


    // 画像グリッド既定（左・上・タイルW/H・gapX/Y・行列・スケール・yOffset）
    const DEFAULT_GRID = {
      cols: 4, rows: 4,
      left: 50, top: 510,
      tileW: 225, tileH: 340, // tileH は今は固定（将来スライダー余地）
      gapX: 24, gapY: 38,
      scale: 2, yOffset: 0
    };
    const DEFAULT_BOTTOM = DEFAULT_GRID.top + (DEFAULT_GRID.rows - 1) * (DEFAULT_GRID.tileH + DEFAULT_GRID.gapY) + DEFAULT_GRID.tileH;

    // ユーティリティ
    const cssEscape = (s)=> s.replace(/\"/g,'\\"');
    const normalizeKey = (s)=> String(s||'')
      .replace(/[\s\u3000]/g,'')
      .replace(/[×✕xX＊*·・]/g,'x')
      .replace(/[()（）\[\]【】]/g,'')
      .trim();

// 全角数字を半角へ（"１２３" → "123"）
function toHalfWidthDigits(s){
  return String(s||'').replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
}

    function computeTopFromBottom(rows){
      rows = Math.max(OCR_CONST.ROWS_MIN, Math.min(OCR_CONST.ROWS_MAX, Number(rows) || DEFAULT_GRID.rows));
      const tileH = DEFAULT_GRID.tileH; // いまは固定
      const gapY  = DEFAULT_GRID.gapY;
      const stepY = tileH + gapY;
      return Math.round(DEFAULT_BOTTOM - tileH - (rows - 1) * stepY);
    }

    // gapX のクランプ（画像幅・列数・タイル幅・left から算出）
    function getGapXClamp(imgWidth, p){
      let max;
      if (p.cols <= 1){
        max = Math.max(0, Math.floor(imgWidth - p.left - p.tileW));
      } else {
        const numer = imgWidth - p.left - p.tileW * p.cols;
        max = Math.floor(numer / Math.max(1, (p.cols - 1)));
        if (!Number.isFinite(max) || max < 0) max = 0;
      }
      return { min: 0, max };
    }

    // yOffset のクランプ（画面高さに対する安全範囲）
    function getYOffsetClamp(imgHeight, p){
      const baseTop = computeTopFromBottom(p.rows);
      const min = Math.max(-Math.floor(p.tileH*0.5), -baseTop); // 上へ行きすぎ防止
      const bottom = baseTop + (p.rows-1)*(p.tileH+p.gapY) + p.tileH;
      const max = Math.min(Math.floor(p.tileH*0.5), Math.max(0, imgHeight - bottom));
      return { min, max };
    }

    // UI値をパラメタ化
    let gridRowCount = OCR_CONST.ROWS_DEF;
    function getGridParamsFromUI(){
      return {
        cols: DEFAULT_GRID.cols,
        rows: gridRowCount,
        left: DEFAULT_GRID.left,
        top: computeTopFromBottom(gridRowCount) + DEFAULT_GRID.yOffset + Number(document.getElementById('cameraSlider2')?.dataset.yofs||0),
        tileW: DEFAULT_GRID.tileW,
        tileH: DEFAULT_GRID.tileH,
        gapX: Number(document.getElementById('cameraSlider1')?.dataset.gapx||DEFAULT_GRID.gapX),
        gapY: DEFAULT_GRID.gapY,
        scale: DEFAULT_GRID.scale,
        yOffset: Number(document.getElementById('cameraSlider2')?.dataset.yofs||0)
      };
    }

    // スライダーへ画像依存の min/max を反映
    function applyGapXClampToUI(img, p){
      const el = document.getElementById('cameraSlider1'); if(!el) return;
      const clamp = getGapXClamp(img.width, p);
      el.min = '0';
      el.max = '100';
      // 0..100 を clamp.min..clamp.max に射影
      const cur = Number(el.value||'50');
      const mapped = Math.round(clamp.min + (clamp.max - clamp.min) * (cur/100));
      el.dataset.gapx = String(mapped);
      el.title = `gapX: ${mapped} (min:${clamp.min}, max:${clamp.max})`;
    }
    function applyYOffsetClampToUI(img, p){
      const el = document.getElementById('cameraSlider2'); if(!el) return;
      const clamp = getYOffsetClamp(img.height, p);
      el.min = '0'; el.max = '100';
      const cur = Number(el.value||'50');
      const mapped = Math.round(clamp.min + (clamp.max - clamp.min) * (cur/100));
      el.dataset.yofs = String(mapped);
      el.title = `yOffset: ${mapped} (min:${clamp.min}, max:${clamp.max})`;
    }

    // 画像読込
    function loadImageAny(fileOrUrl){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=> resolve(img);
        img.onerror = (e)=> reject(new Error('image load error'));
        if (fileOrUrl instanceof File) img.src = URL.createObjectURL(fileOrUrl);
        else img.src = String(fileOrUrl);
      });
    }


    // キャンバス切り出し
    function extractTileCanvas(img, p, r, c){
      const sx = p.left + c * (p.tileW + p.gapX);
      const sy = p.top  + r * (p.tileH + p.gapY);
      const canvas = document.createElement('canvas');
      canvas.width = p.tileW * p.scale; canvas.height = p.tileH * p.scale;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, sx, sy, p.tileW, p.tileH, 0, 0, canvas.width, canvas.height);
      return canvas;
    }

    // サムネイル生成
    let __lastFile = null;
    async function buildTileThumbnails(file){
      if(!file) return;
      const p   = getGridParamsFromUI();
      const img = await loadImageAny(file);
      applyGapXClampToUI(img, p);
      applyYOffsetClampToUI(img, p);
      const pClamped = getGridParamsFromUI();

      const wrap = document.getElementById('tileThumbs');
      const best = document.getElementById('bestLine');
      if (wrap) wrap.innerHTML = '';
      if (best) best.textContent = '';

      const stepX = pClamped.tileW + pClamped.gapX;
      const stepY = pClamped.tileH + pClamped.gapY;
      const usableW = Math.max(0, img.width - pClamped.left + pClamped.gapX);
      const maxCols = Math.max(1, Math.floor(usableW / stepX));
      const effCols = Math.min(pClamped.cols, maxCols);

      const scale = Math.max(0.05, Math.min(1, OCR_CONST.THUMB_W / pClamped.tileW));
      const tc = document.createElement('canvas');
      tc.width  = Math.round(pClamped.tileW * scale);
      tc.height = Math.round(pClamped.tileH * scale);
      const tctx = tc.getContext('2d'); tctx.imageSmoothingEnabled = true; tctx.imageSmoothingQuality='high';

      let tileIndex = 0;
      for (let r=0; r<pClamped.rows; r++){
        for (let c=0; c<effCols; c++){
          tctx.clearRect(0,0,tc.width,tc.height);
          const sx = pClamped.left + c * stepX;
          const sy = pClamped.top  + r * stepY;
          tctx.drawImage(img, sx, sy, pClamped.tileW, pClamped.tileH, 0, 0, tc.width, tc.height);
          const thumb = new Image(); thumb.src = tc.toDataURL('image/png');
          thumb.alt = `tile ${++tileIndex}`; thumb.title = `tile ${tileIndex} (row ${r+1}, col ${c+1})`;
          thumb.className = 'tile-thumb';
          wrap?.appendChild(thumb);
        }
      }
    }

    // デバッグ出力
    function setDebugLines(lines){
      const dbg = document.getElementById('ocrDebug');
      const pre = document.getElementById('debugPre');
      if (!dbg || !pre) return;
      if (!OCR.debug){ dbg.style.display='none'; return; }
      dbg.style.display='';
      pre.textContent = lines || '';
    }

    // ---- Tesseract 準備 ----
async function ensureTesseract(){
  if (OCR.loading) { while(!OCR.langReady) await new Promise(r=>setTimeout(r,60)); return; }
  if (OCR.langReady) return;
  OCR.loading = true;
  try {
    const CDN = {
      esm:   'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.esm.min.js',
      umd:   'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js',
      worker:'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/worker.min.js',
      core:  'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.0/tesseract-core.wasm.js',
      lang:  'https://tessdata.projectnaptha.com/4.0.0'
    };

    let TesseractNS = (typeof window !== 'undefined') ? window.Tesseract : undefined;
    if (!TesseractNS) {
      try { const mod = await import(CDN.esm); TesseractNS = mod?.default || mod; } catch(_) {}
    }
    if (!TesseractNS || typeof TesseractNS.createWorker !== 'function') {
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = CDN.umd; s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('failed to load tesseract.min.js'));
        document.head.appendChild(s);
      });
      TesseractNS = window.Tesseract;
    }
    const createWorker = TesseractNS?.createWorker;
    if (typeof createWorker !== 'function') throw new Error('Unable to acquire Tesseract.createWorker');

    const OPTS = { workerPath: CDN.worker, corePath: CDN.core, langPath: CDN.lang };

    // 日本語（名前）— 単一行
    OCR.W_NAME = await createWorker('jpn', undefined, OPTS);
    await OCR.W_NAME.setParameters({
      tessedit_char_blacklist: '0123456789',
      tessedit_pageseg_mode: 7
    });

    // 英語（数字）— 単一行／x記号も許容（従来どおり）
    OCR.W_DIG  = await createWorker('eng', undefined, OPTS);
    await OCR.W_DIG.setParameters({
      tessedit_char_whitelist: '0123456789xX×✕',
      tessedit_pageseg_mode: 7,
      classify_bln_numeric_mode: 1
    });

    OCR.langReady = true;
  } finally {
    OCR.loading = false;
  }
}

    // 文字列距離（部分距離の最小：名前→候補）
    function levenshtein(a,b){
      const m=a.length, n=b.length; if (!m) return n; if (!n) return m;
      const dp=Array.from({length:m+1},()=>new Array(n+1).fill(0));
      for (let i=0;i<=m;i++) dp[i][0]=i; for (let j=0;j<=n;j++) dp[0][j]=j;
      for (let i=1;i<=m;i++){
        const ca=a.charCodeAt(i-1);
        for (let j=1;j<=n;j++){
          const cb=b.charCodeAt(j-1);
          const cost = (ca===cb)?0:1; // 置換
          dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
        }
      }
      return dp[m][n];
    }
    function minSubstrDistance(text, key){
      if (!text||!key) return Infinity;
      const t = normalizeKey(text), k = normalizeKey(key);
      if (!t||!k) return Infinity;
      let best = Infinity;
      for (let i=0; i<=t.length-k.length; i++){
        const sub = t.slice(i, i+k.length);
        const d = levenshtein(sub, k);
        if (d < best) best = d;
        if (best === 0) break;
      }
      return best;
    }

    // 食材名あいまいマッチ（トークン投票＋部分距離）
    let ING_FULL_KEYS = [];
    let KEYWORD_INDEX = new Map(); // token → Set<ingId>

    function buildIngredientMatchers(){
      const list = DATASET.ingredients || [];
      ING_FULL_KEYS = list.map(i=> normalizeKey(i.name));
      KEYWORD_INDEX = new Map();
      list.forEach((ing, id)=>{
        const all = [ing.name, ...(ing.aliases||[])];
        for (const s of all){
          String(s).split(/[^\wぁ-ゔァ-ヴー一-龠]+/).map(x=>normalizeKey(x)).filter(x=>x.length>=2)
            .forEach(tok=>{
              if (!KEYWORD_INDEX.has(tok)) KEYWORD_INDEX.set(tok, new Set());
              KEYWORD_INDEX.get(tok).add(id);
            });
        }
      });
    }

    function matchIngredientByTokens(tokens, compactText){
      const votes = new Map();
      for (const t of tokens){
        const s = normalizeKey(t);
        const ids = KEYWORD_INDEX.get(s);
        if (!ids) continue;
        ids.forEach(id => votes.set(id, (votes.get(id)||0) + 1));
      }
      if (votes.size){
        let bestId=null, bestVote=-1, bestDist=Infinity;
        for (const [id, v] of votes){
          const full = ING_FULL_KEYS[id] || '';
          const d = minSubstrDistance(compactText||'', full||'');
          if (v > bestVote || (v===bestVote && d < bestDist)){
            bestId = id; bestVote = v; bestDist = d;
          }
        }
        if (bestDist <= OCR_CONST.MAX_DIST) return { id: bestId, votes: bestVote, dist: bestDist };
      }
      // 距離のみ全探索
      const text = compactText||'';
      let pickId=null, pickD=Infinity;
      for (let id=0; id<ING_FULL_KEYS.length; id++){
        const d = minSubstrDistance(text, ING_FULL_KEYS[id]);
        if (d < pickD){ pickD=d; pickId=id; if (d===0) break; }
      }
      if (pickD<=OCR_CONST.MAX_DIST) return { id: pickId, votes: 0, dist: pickD };
      return null;
    }

    // タイルOCR（名前＋数量）：数量は見つからない場合は「不採用」
async function recognizeTile(tileCanvas, up=1.0){
  let inputCanvas = tileCanvas;
  if (up > 1.01){
    const UP_CAP = 3.0; // 端末保護
    const f = Math.min(up, UP_CAP);
    const upW = Math.round(tileCanvas.width  * f);
    const upH = Math.round(tileCanvas.height * f);
    const can  = document.createElement('canvas');
    can.width = upW; can.height = upH;
    const ctx = can.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tileCanvas, 0, 0, tileCanvas.width, tileCanvas.height, 0, 0, upW, upH);
    inputCanvas = can;
  }
  const dataURL = inputCanvas.toDataURL('image/png');

  // ★ 並列で実行（名前・数字）
  const [r1, r2] = await Promise.all([
    OCR.W_NAME.recognize(dataURL),
    OCR.W_DIG .recognize(dataURL)
  ]);

  const rawName  = r1.data.text || '';
  const rawDigit = r2.data.text || '';
  const nameNoSp = normalizeKey(rawName);
  const digitNoSp= normalizeKey(rawDigit);

  const tokens = rawName
    .replace(/[×✕xX]/g, ' ')
    .replace(/[^一-龠ぁ-ゔァ-ヴーa-zA-Z0-9]/g, ' ')
    .split(/\s+/)
    .map(s=>normalizeKey(s))
    .filter(s=>s.length>=2);
  const m = matchIngredientByTokens(tokens, nameNoSp);

// 数量抽出（優先順：rawDigit の「x + 数字」→ rawName の「x + 数字」→ 数字単独）
let qty = 0;
// 全角→半角、スペース正規化（全角スペース含む）
const rdNorm = toHalfWidthDigits(rawDigit).replace(/\u3000/g,' ').replace(/\s+/g,' ').trim();
const rnNorm = toHalfWidthDigits(rawName ).replace(/\u3000/g,' ').replace(/\s+/g,' ').trim();

// 1) "x"（×/✕含む）の直後の数字（1〜3桁）を最優先
let mQty = rdNorm.match(/[x×✕]\s*([0-9]{1,3})/i);
if (!mQty) mQty = rnNorm.match(/[x×✕]\s*([0-9]{1,3})/i);

if (mQty && mQty[1]) {
  qty = parseInt(mQty[1], 10) || 0;
} else {
  // 2) フォールバック：rawDigit 内の数字列（1〜3桁）から「桁が長い方」を優先
  const nums = [...rdNorm.matchAll(/\b([0-9]{1,3})\b/g)].map(n => n[1]);
  if (nums.length) {
    nums.sort((a,b) => b.length - a.length); // 3桁 > 2桁 > 1桁
    qty = parseInt(nums[0], 10) || 0;
  }
}


  // ★ デバッグON時に生文字列をコンソール出力（倍率も表示）
  if (OCR.debug) {
    try {
      const rn = (rawName  || '').replace(/\n/g, ' ');
      const rd = (rawDigit || '').replace(/\n/g, ' ');
      console.log(`[OCR][RAW] scale=${up}  name="${rn}"  digit="${rd}"`);
    } catch (_) {}
  }

  const bestName = (m!=null) ? (DATASET.ingredients[m.id]?.name || null) : null;
  return { best: m, bestName, qty, rawName, rawDigit, tokens, nameNoSp, digitNoSp };
}

function findStockInputByName(name){
      const row = document.querySelector(`#totalTable tr[data-ing="${cssEscape(name)}"]`);
      return row ? row.querySelector('input[type=number]') : null;
    }

// 右下トースト：常に「上書きしました」だけ表示
function showToastApply(/* ing, qty, source */){
  try {
    // 既存のトーストエリアを流用 or なければ作成
    let area = document.getElementById('toastArea');
    if (!area) {
      area = document.createElement('div');
      area.id = 'toastArea';
      area.className = 'position-fixed bottom-0 end-0 p-3';
      area.style.zIndex = '1080';
      document.body.appendChild(area);
    }

    // シンプルなトーストを生成（Bootstrap有無を問わず動く最小構成）
    const t = document.createElement('div');
    t.className = 'toast show border-0 shadow-sm';
    t.setAttribute('role','status');
    t.setAttribute('aria-live','polite');
    t.setAttribute('aria-atomic','true');
    t.innerHTML = `<div class="toast-body">上書きしました</div>`;

    area.appendChild(t);

    // 1.4秒で自動消去（既存の挙動に合わせて短め）
    setTimeout(() => {
      t.classList.remove('show'); // 見た目だけ消す
      t.classList.add('hide');
      // 少し待ってからDOMから除去
      setTimeout(() => { t.remove(); }, 300);
    }, 1400);
  } catch (e) {
    // 万が一DOM生成に失敗した時はログにのみ出す
    console.log('上書きしました');
  }
}


    function addHistoryLine(msg){ /* 将来：履歴UIに拡張余地 */ console.log('[HIST]', msg); }

function renderConfirmPanelUnified(items){
  const root = document.getElementById('confirmPanel');
  if (!root) return;
  root.innerHTML = '';

  if (!items || !items.length) { root.classList.add('d-none'); return; }

  const card = document.createElement('div');
  card.className = 'card';

  // Header
  const hd = document.createElement('div');
  hd.className = 'card-header d-flex align-items-center justify-content-between';
  const title = document.createElement('div');
  title.innerHTML = `<strong>確認（未自動適用）</strong> <small class="text-muted">${items.length}件</small>`;
  const discardAllBtn = document.createElement('button');
  discardAllBtn.className = 'btn btn-sm btn-outline-secondary';
  discardAllBtn.textContent = '全部破棄';
  discardAllBtn.addEventListener('click', () => { list.innerHTML = ''; root.classList.add('d-none'); });
  hd.appendChild(title); hd.appendChild(discardAllBtn);
  card.appendChild(hd);

  // Body（シンプル列挙）
  const body = document.createElement('div');
  body.className = 'card-body p-2';

  const list = document.createElement('div');
  list.className = 'list-group';

  const buildIngSelect = (defaultName) => {
    const sel = document.createElement('select');
    sel.className = 'form-select form-select-sm';
    const ph = document.createElement('option');
    ph.value = ''; ph.textContent = '— 食材を選択 —';
    sel.appendChild(ph);
    (DATASET.ingredients || []).forEach(rec => {
      const opt = document.createElement('option');
      opt.value = rec.name; opt.textContent = rec.name;
      if (defaultName && defaultName === rec.name) opt.selected = true;
      sel.appendChild(opt);
    });
    return sel;
  };

  items.forEach((t, idx) => {
    const row = document.createElement('div');
    row.className = 'list-group-item d-flex align-items-center gap-2';
    row.dataset.idx = String(idx);

    // thumb
    const thumb = new Image();
    thumb.src = t.thumb; thumb.alt = 'tile';
    thumb.className = 'tile-thumb';
    row.appendChild(thumb);

    // 食材名（確定→ラベル / 不明→セレクト）
    let ingFixed = !!t.bestName && t.bestDist <= (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1);
    let ingName = t.bestName || '';

    let ingNode;
    if (ingFixed) {
      ingNode = document.createElement('span');
      ingNode.className = 'badge badge-soft';
      ingNode.textContent = ingName;
    } else {
      ingNode = buildIngSelect(ingName || '');
      ingNode.style.minWidth = '180px';
    }
    row.appendChild(ingNode);

    // 数量
    const qtyInput = document.createElement('input');
    qtyInput.type = 'number';
    qtyInput.className = 'form-control form-control-sm w-6ch';
    qtyInput.min = '0'; qtyInput.step = '1';
    qtyInput.value = String(Math.max(0, parseInt(t.qty || '0', 10) || 0));
    row.appendChild(qtyInput);

    // 破棄（右端へ）
    const trash = document.createElement('button');
    trash.className = 'btn btn-sm btn-outline-secondary ms-auto';
    trash.textContent = '破棄';
    trash.addEventListener('click', () => { row.remove(); if (!list.querySelector('.list-group-item')) root.classList.add('d-none'); });
    row.appendChild(trash);

    // データ取得
    row.__getResolved = () => {
      const ingResolved = (ingNode.tagName === 'SELECT') ? ingNode.value : ingName;
      const q = parseInt(qtyInput.value || '0', 10) || 0;
      return { ing: ingResolved, qty: q };
    };

    list.appendChild(row);
  });

  body.appendChild(list);
  card.appendChild(body);

  // Footer（一括上書き）
  const ft = document.createElement('div');
  ft.className = 'card-footer text-end';
  const applyBtn = document.createElement('button');
  applyBtn.className = 'btn btn-sm btn-primary';
  applyBtn.textContent = '上書き（すべて）';
applyBtn.addEventListener('click', () => {
  const rows = [...list.querySelectorAll('.list-group-item')];
  let applied = 0;
  for (const row of rows) {
    const { ing, qty } = row.__getResolved?.() || {};
    if (!ing || !(Number.isFinite(qty) && qty > 0)) continue;
    const input = findStockInputByName(ing);
    if (!input) continue;
    const prev = parseInt(input.value || '0', 10) || 0;
    input.value = String(qty);
    input.dispatchEvent(new Event('input', { bubbles: true }));
    applied++;
  }
  if (applied > 0) addHistoryLine(`一括上書き: ${applied}件 (confirm unified)`);
  root.classList.add('d-none');
});

  ft.appendChild(applyBtn);
  card.appendChild(ft);

  root.appendChild(card);
  root.classList.remove('d-none');
}

// OCRハイブリッド（倍率リトライ → 自動/確認 反映）
async function ocrHybridGrid(file, scaleOverride){
  await ensureTesseract();
  const status = (t)=>{ const s=document.getElementById('ocrStatus'); if(s) s.textContent=t||''; };

  // ★ OCR開始：ボタン無効化＋スナップショット保存
  setRunButtonEnabled(false);
  PRE_OCR_SNAPSHOT = captureStockSnapshot();

  try{
    status('読み取り準備…');
    const img = await loadImageAny(file);
    applyGapXClampToUI(img, getGridParamsFromUI());
    applyYOffsetClampToUI(img, getGridParamsFromUI());
    const p = getGridParamsFromUI();

    // グリッド生成
    const grid = [];
    const stepX = p.tileW + p.gapX;
    const stepY = p.tileH + p.gapY;
    const usableW = Math.max(0, img.width - p.left + p.gapX);
    const maxCols = Math.max(1, Math.floor(usableW / stepX));
    const effCols = Math.min(p.cols, maxCols);
    for (let r=0; r<p.rows; r++){
      for (let c=0; c<effCols; c++){
        grid.push({ r, c });
      }
    }

    // サムネ＆タイル
    const thumbs = [];
    const tiles  = [];
    const sc = Math.max(0.05, Math.min(1, OCR_CONST.THUMB_W / p.tileW));
    const tc = document.createElement('canvas'); tc.width=Math.round(p.tileW*sc); tc.height=Math.round(p.tileH*sc);
    const tctx = tc.getContext('2d'); tctx.imageSmoothingEnabled=true; tctx.imageSmoothingQuality='high';

    for (const cell of grid){
      const tile = extractTileCanvas(img, p, cell.r, cell.c);
      tiles.push(tile);
      tctx.clearRect(0,0,tc.width,tc.height);
      tctx.drawImage(tile, 0, 0, p.tileW*p.scale, p.tileH*p.scale, 0, 0, tc.width, tc.height);
      thumbs.push(tc.toDataURL('image/png'));
    }

    // 倍率：初回0.75 → 既定配列
    const scales = (scaleOverride ? [scaleOverride] : [0.75, ...OCR_CONST.RETRY_SCALES]);
    const MAX_PAR = 2; // 同時並列数

    status('読み取り中… 0/'+tiles.length);

    // 各タイル：早期打ち切りしながら処理
    const results = new Array(tiles.length);
    let done = 0, nextIdx = 0;

    async function processOne(idx){
      const can = tiles[idx];
      let picked = null;
      for (const s of scales){
        const r = await recognizeTile(can, s);
        r.thumb = thumbs[idx];
        picked = r;
        // 自動採用条件（距離≤1 & 数量あり）を満たしたら打ち切り
        if (r.best && r.best.id!=null && Number.isFinite(r.qty) && r.qty>0 && r.best.dist <= (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1)) break;
      }
      results[idx] = picked;
      status(`読み取り中… ${++done}/${tiles.length}`);
    }

    async function worker(){
      while(true){
        const i = nextIdx++;
        if (i >= tiles.length) break;
        await processOne(i);
      }
    }
    const workers = Array.from({length: Math.min(MAX_PAR, tiles.length)}, ()=>worker());
    await Promise.all(workers);

    // 仕分け
    const auto = [];
    const duplicates = new Map(); // ing -> tiles[]
    const leftovers = [];

    for (let i=0;i<results.length;i++){
      const t = results[i];
      if (!(Number.isFinite(t.qty) && t.qty>0)) { leftovers.push(t); continue; }
      if (!t.best || t.best.id==null) { leftovers.push(t); continue; }
      const ing = DATASET.ingredients[t.best.id]?.name;
      if (!ing) { leftovers.push(t); continue; }
      t.bestName = ing;
      if (isAutoApplyCase(t)) { auto.push(t); continue; }
      if (!duplicates.has(ing)) duplicates.set(ing, []);
      duplicates.get(ing).push(t);
    }

    // 自動上書き（※トーストはここでは出さない）
    for (const t of auto){
      const input = findStockInputByName(t.bestName);
      if (!input) continue;
const prev = parseInt(input.value || '0', 10) || 0;
input.value = String(t.qty);
input.dispatchEvent(new Event('input', { bubbles:true }));
// トーストは実行後に1回だけ表示（ここでは出さない）
addHistoryLine(`上書き: ${t.bestName} ← ${t.qty} (auto)`);
    }

    // 統合：未自動適用アイテムの列挙リスト
    const toConfirm = [];
    const included = new Set();

    // 重複（距離昇順で代表を1件）
    for (const [ing, tilesArr] of duplicates.entries()){
      if (tilesArr.length > 1) {
        tilesArr.sort((a,b) => (a.best?.dist ?? 99) - (b.best?.dist ?? 99));
        const pick = tilesArr[0];
        if (pick && !included.has(pick)) { toConfirm.push(pick); included.add(pick); }
      } else if (tilesArr.length === 1) {
        const pick = tilesArr[0];
        if (pick && !included.has(pick)) { toConfirm.push(pick); included.add(pick); }
      }
    }

    // 数量しきい値以上（単発でも）
    results.forEach(t => {
      if (included.has(t)) return;
      if (t.best && Number.isFinite(t.qty) && t.qty >= (OCR_CONST.AUTO_CONFIRM_QTY_MIN ?? 300)) {
        toConfirm.push(t); included.add(t);
      }
    });

    // あいまい／数量未取得
    results.forEach(t => {
      if (included.has(t)) return;
      const needConfirm =
        !t.best ||
        (t.best && t.best.dist > (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1)) ||
        !(Number.isFinite(t.qty) && t.qty > 0);
      if (needConfirm) { toConfirm.push(t); included.add(t); }
    });

    // 確認UI
    if (toConfirm.length){
      toConfirm.forEach(t => { t.bestDist = t.best?.dist ?? null; });
      renderConfirmPanelUnified(toConfirm);
    } else {
      document.getElementById('confirmPanel')?.classList.add('d-none');
    }

    // サムネイル表示（カード内横スクロール）
    document.getElementById('gridPreview')?.classList.remove('d-none');
    await buildTileThumbnails(file);

    status(results.length ? '読み取り完了' : '検出なし');

    // ★ OCR完了：ここで1回だけトースト表示（3秒間は読取ボタンを無効のまま）
    showUndoToastAfterRun();

    return results.length;
  } catch (err){
    console.error(err); status('エラー');
    // 失敗時はトースト出さず、ボタン再有効化＆スナップショット破棄
    PRE_OCR_SNAPSHOT = null;
    setRunButtonEnabled(true);
    return 0;
  }
}

function isAutoApplyCase(t){
  if (!t || !t.best || t.best.id==null) return false;
  if (!(Number.isFinite(t.qty) && t.qty>0)) return false; // 数量必須
  // 数量が大きすぎる場合は確認へ回す
  if (t.qty >= OCR_CONST.AUTO_CONFIRM_QTY_MIN) return false;
  // 距離が十分小さい（≦1）のみ自動上書き
  return (t.best.dist <= (OCR_CONST.AUTO_APPLY_DIST_MAX ?? 1));
}


    // カメラUI（開閉・行数・スライダー・読取）
    function bindCameraUI() {
      const toggleBtn = document.getElementById('cameraToggle');
      const refreshBtn = document.getElementById('cameraRefresh');
      const area = document.getElementById('cameraArea');
      const file = document.getElementById('cameraFile');
      const fileBtn = document.getElementById('fileSelectBtn');
      const fileName = document.getElementById('fileName');
      const s1 = document.getElementById('cameraSlider1');
      const s2 = document.getElementById('cameraSlider2');
      const readBtn = document.getElementById('cameraReadBtn');
      const rowCount = document.getElementById('rowCount');
      const gridPreview = document.getElementById('gridPreview');
      const debugToggle = document.getElementById('debugToggle');

      OCR.status = document.getElementById('ocrStatus');

      const setOpen = (open) => {
        toggleBtn.setAttribute('aria-pressed', open ? 'true' : 'false');
        toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
        area.classList.toggle('d-none', !open);
        area.setAttribute('aria-hidden', open ? 'false' : 'true');
        refreshBtn.classList.toggle('d-none', !open);
        if (!open) gridPreview.classList.add('d-none');
        toggleBtn.classList.toggle('btn-primary', open);
        toggleBtn.classList.toggle('btn-outline-secondary', !open);
      };
      setOpen(false);

      toggleBtn.addEventListener('click', () => {
        const open = toggleBtn.getAttribute('aria-pressed') !== 'true';
        setOpen(open);
      });

      fileBtn.addEventListener('click', () => file.click());
      file.addEventListener('change', async () => {
        const has = file.files && file.files.length;
        const name = has ? file.files[0].name : '未選択';
        fileName.textContent = name;
        gridPreview.classList.toggle('d-none', !has);
        if (!has) { gridPreview.classList.add('d-none'); document.getElementById('tileThumbs').innerHTML=''; return; }
        __lastFile = file.files[0];
        await buildTileThumbnails(__lastFile);
      });

      function updateRowButtons() {
        [...rowCount.querySelectorAll('button[data-rows]')].forEach(btn => {
          const isActive = parseInt(btn.dataset.rows, 10) === gridRowCount;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }
      rowCount.addEventListener('click', async (e) => {
        const btn = e.target.closest('button[data-rows]');
        if (!btn) return;
        gridRowCount = parseInt(btn.dataset.rows, 10) || 4;
        updateRowButtons();
        if (__lastFile) await buildTileThumbnails(__lastFile);
      });
      updateRowButtons();

      s1.addEventListener('input', async () => { if (__lastFile) await buildTileThumbnails(__lastFile); });
      s2.addEventListener('input', async () => { if (__lastFile) await buildTileThumbnails(__lastFile); });

      refreshBtn.addEventListener('click', async () => {
        gridRowCount = 4; updateRowButtons();
        s1.value = '50'; s2.value = '50'; delete s1.dataset.gapx; delete s2.dataset.yofs;
        file.value = ''; fileName.textContent = '未選択';
        document.getElementById('tileThumbs').innerHTML='';
        gridPreview.classList.add('d-none');
        document.getElementById('confirmPanel').classList.add('d-none');
        document.getElementById('leftoverPanel').classList.add('d-none');
        if (OCR.status) OCR.status.textContent = '';
      });

      debugToggle.addEventListener('change', ()=>{ OCR.debug = !!debugToggle.checked; if (!OCR.debug) setDebugLines(''); else setDebugLines('(ON)'); });

      readBtn.addEventListener('click', async () => {
        try{
          readBtn.disabled = true;
          if (!__lastFile) { alert('画像を選択してください'); return; }
          await ocrHybridGrid(__lastFile);
        }catch(e){ console.error(e); alert('読取中にエラーが発生しました'); }
        finally{ readBtn.disabled = false; }
      });
    }

    // =========================
    // 起動
    // =========================
    (async function init(){
      DATASET = await loadDataset();
      buildIndexes(DATASET);
      buildIngredientMatchers();
      bindGroup1();
      bindClearAll();
      bindCameraUI();
      renderAll();
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
